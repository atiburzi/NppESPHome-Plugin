<Components>

<Component>
  <Name>ESP32</Name>
  <Category>Microcontrollers</Category>
  <Description>ESP32 microcontroller configuration with extended options (board variant, flash size, CPU freq, framework, advanced settings).</Description>
  <YAML><![CDATA[
esp32:                                 # https://www.esphome.io/components/esp32/   
  variant: esp32dev                    # choose the correct variant: esp32, esp32s2, esp32s3, esp32c2, esp32c3, esp32c5, esp32c6, esp32h2 or esp32p4 :contentReference[oaicite:3]{index=3}
  board: esp32dev                      # PlatformIO board ID (optional when variant is used) :contentReference[oaicite:4]{index=4}
  flash_size: 4MB                      # flash size: 2MB, 4MB, 8MB, 16MB, 32MB. Defaults often 4MB. :contentReference[oaicite:5]{index=5}
  cpu_frequency: 160MHz                # CPU frequency: 40MHz, 80MHz, 160MHz, 240MHz, 360MHz, 400MHz depending on variant :contentReference[oaicite:6]{index=6}
  framework:
    type: esp-idf                      # framework type: 'esp-idf' or 'arduino' (ESP-IDF recommended for many variants) :contentReference[oaicite:7]{index=7}
    version: recommended               # 'recommended', 'latest', or 'dev'
    source: default                    # optional custom framework source repository
    platform_version: latest           # optional override of PlatformIO package version
    sdkconfig_options:                 # optional advanced ESP-IDF configuration mapping
      CONFIG_MY_CUSTOM_OPTION: true
    log_level: INFO                    # optional log level: ERROR / NONE / WARN / INFO / DEBUG / VERBOSE
    advanced:                          # advanced settings (ESP-IDF only)
      enable_lwip_dhcp_server: false
      enable_lwip_mdns_queries: false
      enable_lwip_bridge_interface: false
      enable_lwip_tcpip_core_locking: true
      enable_lwip_check_thread_safety: true
      ignore_efuse_custom_mac: false
      ignore_efuse_mac_crc: false             # only for original ESP32 + esp-idf :contentReference[oaicite:8]{index=8}
      execute_from_psram: false               # On certain variants with PSRAM it can be enabled :contentReference[oaicite:9]{index=9}
  safe_mode: true                       # optional: enable safe mode on boot failures
  power_save_mode: none                 # optional: none / light / high
  board_build:
    flash_size: 16MB                    # example: if board has larger flash
    psram_enabled: true                 # optional: enable PSRAM if supported
    cpu_frequency: 240MHz               # example alternative CPU frequency
    build_flags:
      - "-DBOARD_HAS_PSRAM"
      - "-mfix-esp32-psram-cache-issue"
  partitions: partitions.csv            # optional: external file for partition scheme
]]></YAML>
</Component>

<Component>
  <Name>ESP8266</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller ESP8266 configuration with extended options.</Description>
  <YAML><![CDATA[
esp8266:                         # https://www.esphome.io/components/esp8266/
  board: nodemcuv2               # other options: esp01_1m, d1_mini, esp07, esp12e, esp8285, esp_wroom_02, esp210, modwifi
  framework:
    version: recommended         # options: recommended / latest / dev
  restore_from_flash: false      # restore persistent preferences from flash (true/false)
  board_flash_mode: dout         # options: qio / qout / dio / dout
  early_pin_init: true           # initialize GPIOs early (true/false)
  safe_mode: true                # enable safe mode on boot failures
  power_save_mode: none          # WiFi power saving: none / light / high
  board_build:
    flash_size: 1MB              # typical flash sizes: 512KB / 1MB / 2MB / 4MB
    cpu_frequency: 80MHz         # CPU frequency: 80MHz / 160MHz
  framework:
    type: arduino                # available type: arduino
    version: recommended         # or latest / dev
    platform_version: latest     # override PlatformIO core if needed
]]></YAML>
</Component>

<Component>
  <Name>RP2040</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller RP2040 (e.g., Raspberry Pi Pico / Pico W) configuration.</Description>
  <YAML><![CDATA[
rp2040:                          # https://www.esphome.io/components/rp2040/
  board: rpipicow                 # valid option: rpipicow (original Pico W) :contentReference[oaicite:3]{index=3}
  watchdog_timeout: 0s            # optional: reboot if hung longer than this (e.g., "500ms", "2s") :contentReference[oaicite:4]{index=4}
  framework:
    # platform_version is no longer required in newer ESPHome versions :contentReference[oaicite:5]{index=5}
    type: arduino                 # example: use Arduino-framework (if supported)
    version: latest               # optional: 'latest', 'recommended', or specific version
  board_build:
    flash_size: 2MB               # example: typical size (adjust per board)
    cpu_frequency: 133MHz         # example: typical for RP2040 (if applicable)
  safe_mode: true                 # optional: enable safe mode on boot failures
  power_save_mode: none           # optional: power saving mode: none / light / high
]]></YAML>
</Component>

<Component>
  <Name>BK72xx</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller Beken BK72xx (BK7231N/T etc) configuration via LibreTiny platform in ESPHome.</Description>
  <YAML><![CDATA[
bk72xx:                              # https://docs.libretiny.eu/docs/platform/beken-72xx/
  board: generic-bk7231n-qfn32-tuya  # example: choose correct board ID (e.g. generic-bk7231n-qfn32-tuya, generic-bk7231t-…) 
  framework:
    version: recommended             # options: recommended / latest / dev
  # Optional (advanced) parameters:
  family: bk7231n                    # optional if board auto-detects; specify if necessary
  safe_mode: true                    # optional: reboot in safe mode on boot failure
  power_save_mode: none              # optional: none / light / high
]]></YAML>
</Component>

<Component>
  <Name>RTL87xx</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller Realtek RTL87xx (e.g., RTL8710BN / RTL8710BX) configuration via LibreTiny platform.</Description>
  <YAML><![CDATA[
rtl87xx:                           # https://esphome.io/components/libretiny/
  board: generic-rtl8710bn-2mb-788k    # select the correct board ID (e.g. generic-rtl8710bx-4m-980k, generic-rtl8710bn-2mb-468k, etc.)
  framework:
    version: recommended           # options: recommended / latest / dev
    source: libretiny              # optional: specify custom LibreTiny framework source
  family: rtl8710b                 # optional: specify the chip family (rtl8710b, rtl8720c, etc.) if not auto-detected
  safe_mode: true                  # enable safe mode on boot failures
  power_save_mode: none            # WiFi power saving: none / light / high
  board_build:
    flash_size: 2MB                # adjust to your board’s flash capacity
    cpu_frequency: 125MHz          # example CPU frequency
]]></YAML>
</Component>

<Component>
  <Name>LN882x</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller LN882x (e.g., LN882HKI) configuration via LibreTiny platform for ESPHome.</Description>
  <YAML><![CDATA[
ln882x:                               # https://esphome.io/components/libretiny/
  board: generic-ln882hki             # select the correct board ID (e.g. generic-ln882hki, generic-ln882x, etc.)
  framework:
    version: recommended              # options: recommended / latest / dev
    source: libretiny                 # optional: specify a custom LibreTiny framework source
  family: ln882hki                    # optional: specify chip family if not auto-detected
  safe_mode: true                     # enable safe mode on boot failures
  power_save_mode: none               # WiFi power saving: none / light / high
  board_build:
    flash_size: 2MB                   # adjust according to the actual board
    cpu_frequency: 80MHz              # typical CPU frequency (if supported)
]]></YAML>
</Component>

<Component>
  <Name>nRF52</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller nRF52 (Nordic Semiconductor) configuration via ESPHome (Zephyr-based support).</Description>
  <YAML><![CDATA[
nrf52:                                     # https://www.esphome.io/components/nrf52/
  board: adafruit_feather_nrf52840         # valid example board: adafruit_itsybitsy_nrf52840, xiao_ble, … :contentReference[oaicite:3]{index=3}
  bootloader: mcuboot                      # optional: bootloader type, options include mcuboot / adafruit / adafruit_nrf52_sd132 / adafruit_nrf52_sd140_v6 / adafruit_nrf52_sd140_v7 :contentReference[oaicite:4]{index=4}
  # Optional (advanced) parameters:
  safe_mode: true                          # optional: enable safe mode on boot failure
  power_save_mode: none                    # optional: none / light / high
  dfu:
    reset_pin:
      number: P0.14                        # example pin to trigger DFU mode via USB/CDC :contentReference[oaicite:5]{index=5}
      inverted: true
]]></YAML>
</Component>

<Component>
  <Name>PSRAM</Name>
  <Category>Peripherals</Category>
  <Description>External PSRAM (Pseudo-Static RAM) configuration for ESP32 modules/boards.</Description>
  <YAML><![CDATA[
psram:                           # https://esphome.io/components/psram.html
  mode: quad                     # operating mode of PSRAM: 'quad' (default) or 'octal'
  speed: 80MHz                   # PSRAM clock speed: 40MHz (default) / 80MHz / 120MHz (120MHz only with octal mode + experimental) :contentReference[oaicite:3]{index=3}
  enable_ecc: false              # (Optional, bool) Enable ECC (Error Correction Code) for octal mode only. Default: false. :contentReference[oaicite:4]{index=4}
  disabled: false                # (Optional, bool) Don’t try to initialize PSRAM. Useful when board lacks PSRAM or PSRAM lines are used for other hardware. Default: false. :contentReference[oaicite:5]{index=5}

  # Advanced / optional settings:
  # Note: these may require specific board support or ESP-IDF/Arduino flags.
  board_build:
    flash_size: 16MB             # Example: size of external flash memory; adjust per your board (often used alongside PSRAM)
    cpu_frequency: 240MHz        # Example: CPU frequency; change according to board capabilities
  framework:
    type: esp-idf                # Example framework: esp-idf or arduino
    version: latest              # Or specific version, if needed
  platformio_options:
    build_flags:
      - "-DBOARD_HAS_PSRAM"      # Example flag to manually enable PSRAM on boards where it isn't auto-detected :contentReference[oaicite:6]{index=6}
      - "-mfix-esp32-psram-cache-issue"  # Example workaround for some ESP32-S3 boards with PSRAM cache issues :contentReference[oaicite:7]{index=7}
]]></YAML>
</Component>

<Component>
  <Name>deep_sleep</Name>
  <Category>Peripherals</Category>
  <Description>Deep sleep configuration for ESP8266/ESP32 to minimise power consumption.</Description>
  <YAML><![CDATA[
deep_sleep:                            # https://www.esphome.io/components/deep_sleep/              
  id: deep_sleep_1                     # optional identifier for referencing the component
  run_duration: 10s                    # time to run before entering sleep mode
  sleep_duration: 10min                # time to sleep before next wake-up

  # ESP32-specific wake-up options:
  wakeup_pin:
    number: GPIO33                     # RTC-capable pin on ESP32
    mode: INPUT_PULLUP                 # pin mode configuration
    inverted: false                    # wake on HIGH (false) or LOW (true)
  wakeup_pin_mode: IGNORE              # behaviour if pin is already in wake state: IGNORE / KEEP_AWAKE / INVERT_WAKEUP
  touch_wakeup: true                    # enable touchpad wake‐up (ESP32 only)
  esp32_ext1_wakeup:
    pins:
      - number: GPIO13
      - number: GPIO27
    mode: ANY_HIGH                     # mode for EXT1 wake up: ANY_LOW / ANY_HIGH / ALL_LOW

  # Conditional run durations depending on wake-up reason (ESP32 only):
  wakeup_cause_to_run_duration:
    default: 5s                         # run duration if woke by timer or unspecified cause
    gpio_wakeup_reason: 2s             # run duration if wake was caused by GPIO
    touch_wakeup_reason: 3s            # run duration if wake was caused by touchpad

  # Template/automation based entering of deep sleep:
  on_...:
    then:
      - deep_sleep.enter:
          id: deep_sleep_1
          sleep_duration: !lambda "return (lux < 10) ? 30min : 5min;"

      - deep_sleep.prevent: deep_sleep_1   # prevent sleep when certain condition holds
      - deep_sleep.allow: deep_sleep_1     # allow sleep again after prevent

  # Time-based wake up until - only ESP32:
  until: "06:00:00"                     # wake up at specified time of day
  time_id: sntp_time                   # ID of the time component to use for 'until'

  # Notes for ESP8266:
  # On ESP8266 only run_duration and sleep_duration are supported.
  # You must connect GPIO16 (D0) to the RST pin in order to wake from deep sleep.  

]]></YAML>
</Component>

<Component>
  <Name>ESP32-P4 LDO</Name>
  <Category>Peripherals</Category>
  <Description>Configuration for ESP32-P4 series boards using LDO regulator and power settings.</Description>
  <YAML><![CDATA[
esp_ldo:
  - channel: 3          # The channel number of the LDO regulator to configure. Only channels 3 and 4 are supported (1 and 2 are used internally by the chip.)
    voltage: 2.5V       # The desired output voltage - must be in the range 0.5V to 2.7V.
    adjustable: true    # If true, the output voltage can be adjusted at run-time. Defaults to false.
]]></YAML>
</Component>

<Component>
  <Name>ESPHome Core</Name>
  <Category>Core</Category>
  <Description>Main ESPHome configuration for device identity, network, logs and OTA.</Description>
  <YAML><![CDATA[
esphome:                             # https://www.esphome.io/components/esphome/
  name: my_device                    # device name (used in Home Assistant entities)
  friendly_name: "My Device"         # optional friendly name shown in UI
  platform: ESP32                    # choose correct platform: ESP8266 / ESP32 / rtl87xx / bk72xx / rp2040 / etc.
  board: esp32dev                    # optional: PlatformIO board ID if needed

# Logging configuration
logger:
  level: DEBUG                       # DEBUG / INFO / WARN / ERROR / NONE
  baud_rate: 0                       # set to 0 to disable UART logging (use USB only)

# OTA update configuration
ota:
  password: "OTA_PASSWORD"           # password for over-the-air updates
  safe_mode: true                    # enable safe mode fallback if update fails
  num_attempts: 3                    # number of OTA attempts before fallback

# Web server (optional)
web_server:
  port: 80
  include_internal: false            # include internal pages (e.g., logs, device info)
  auth:
    username: admin
    password: "WEB_PASSWORD"

# WiFi configuration (for network connectivity)
wifi:
  ssid: "Your_SSID"
  password: "Your_PASSWORD"
  fast_connect: true                 # skip waiting for network in station mode when available
  ap:
    ssid: "FallbackAP_%s"            # fallback access point if WiFi fails
    password: "AP_PASSWORD"
  manual_ip:
    static_ip: 192.168.1.50
    gateway: 192.168.1.1
    subnet: 255.255.255.0

# API configuration (integration with Home Assistant)
api:
  encryption:
    key: "32_BYTE_BASE64_KEY"        # 32 byte base64 Pre-Shared Key for encryption
  password: "API_PASSWORD"           # deprecated — use key instead
  reboot_timeout: 15min              # timeout after which auto-reboot if no communication

# Time component (optional)
time:
  - platform: homeassistant          # or sntp / rtt
    id: home_time
    timezone: "Europe/Rome"

# Device uptime and status sensor
uptime:
  id: device_uptime

# Status LED (optional)
status_led:
  pin:
    number: GPIO2
    inverted: false
]]></YAML>
</Component>

<Component>
  <Name>captive_portal</Name>
  <Category>Core</Category>
  <Description>Captive portal for connecting WiFi devices without preconfigured credentials.</Description>
  <YAML><![CDATA[
captive_portal:                     # https://esphome.io/components/captive_portal/
  id: captive_portal_main           # optional identifier
]]></YAML>
</Component>

<Component>
  <Name>external_components</Name>
  <Category>System</Category>
  <Description>Support for loading external/custom components into ESPHome.</Description>
  <YAML><![CDATA[
external_components:                        # https://www.esphome.io/components/external_components/
  - source:                                 # define source of the external component
      type: local                           # type of source: 'local' / 'git' / 'url' / 'directory'
      path: components/my_component         # path for 'local' type: relative to config folder
  dependencies:                             # optional list of other components needed
    - sensor                                # if your custom component uses sensor platform
    - switch
  reload: true                              # optional: whether changes should force full reload
]]></YAML>
</Component>

<Component>
  <Name>globals</Name>
  <Category>System</Category>
  <Description>Global variables for storing and sharing values between components and automations.</Description>
  <YAML><![CDATA[
globals:                              # https://esphome.io/components/globals/
  - id: counter_value                 # unique variable identifier
    type: int                         # variable type: int / float / bool / std::string / custom
    restore_value: yes                # restore last value from flash on boot (yes/no)
    initial_value: '0'                # initial value (stringified)
  - id: is_enabled
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: temperature_offset
    type: float
    restore_value: yes
    initial_value: '1.5'
]]></YAML>
</Component>

<Component>
  <Name>interval</Name>
  <Category>Automation</Category>
  <Description>Defines recurring timed actions executed at fixed intervals.</Description>
  <YAML><![CDATA[
interval:                            # https://esphome.io/components/interval.html
  - interval: 10s                    # time between executions (supports s, min, h, ms)
    then:                            # actions to perform every interval
      - logger.log: "10-second interval triggered"
      - lambda: |-
          id(counter_value) += 1;    // example using a global variable
      - switch.turn_on: led_power
      - delay: 1s
      - switch.turn_off: led_power

  - interval: 1min
    then:
      - logger.log:
          level: INFO
          format: "Running periodic task every minute"
      - component.update: my_sensor  # manually triggers sensor reading
]]></YAML>
</Component>

<Component>
  <Name>wifi</Name>
  <Category>Network</Category>
  <Description>WiFi configuration for ESPHome devices, including credentials, static networking, power settings and fallback AP.</Description>
  <YAML><![CDATA[
wifi:                                 # https://www.esphome.io/components/wifi/
  ssid: "MyWiFiNetwork"               # The name (SSID) of the WiFi network to connect to
  password: "MyWiFiPassword"          # The password for your WiFi network; leave blank for open networks
  # For connecting to multiple networks, use the networks: list instead of ssid/password
  # networks:
  #   - ssid: "FirstNetwork"
  #     password: "Password1"
  #   - ssid: "SecondNetwork"
  #     password: "Password2"

  manual_ip:                          # (optional) Set a static IP address instead of using DHCP
    static_ip: 192.168.1.100          # The static IP address to assign to this device
    gateway: 192.168.1.1              # Your router's IP address
    subnet: 255.255.255.0             # Subnet mask, usually 255.255.255.0
    dns1: 8.8.8.8                     # (optional) Primary DNS server
    dns2: 1.1.1.1                     # (optional) Secondary DNS server

  ap:                                 # (optional) Enable fallback Access Point mode
    ssid: "FallbackHotspot"           # SSID for the fallback AP if WiFi connection fails
    password: "FallbackPassword"      # Password for the hotspot; leave empty for an open AP

  power_save_mode: none               # (optional) WiFi power saving mode: none, light, or high
  output_power: 20dB                  # (optional) WiFi transmit power. Default for ESP32/ESP8266 is 20dB
  fast_connect: false                 # (optional) Skip full WiFi scan for faster connection. Use for hidden or single APs
  reboot_timeout: 15min               # (optional) Time to reboot after losing WiFi, default 15min

  on_connect:                         # (optional) Actions when the device connects to WiFi
    then:
      - logger.log: "Connected to WiFi!"

  on_disconnect:                      # (optional) Actions when the device disconnects from WiFi
    then:
      - logger.log: "Disconnected from WiFi!"

  enable_on_boot: true                # (optional) Whether WiFi is enabled at boot. Default is true

  domain: ".local"                    # (optional) mDNS domain to use, default is ".local"
  use_address: 192.168.1.100          # (optional) Override the address used to connect from Home Assistant
 ]]></YAML>
</Component>


<Component>
  <Name>ethernet</Name>
  <Category>Network</Category>
  <Description>Configuration of Ethernet connectivity for ESPHome, including PHY type, pins and network settings.</Description>
  <YAML><![CDATA[
ethernet:                              # https://www.esphome.io/components/ethernet/
  type: LAN8720                        # The Ethernet chip type; options: LAN8720, IP101, RTL8201, W5500, DM9051, OPENETH, LAN8670
  mdc_pin: GPIO23                      # (Required for RMII chips) Pin for MDC signal
  mdio_pin: GPIO18                     # (Required for RMII chips) Pin for MDIO signal
  clk:                                 # (Required for RMII chips) Clock configuration object
    pin: GPIO17                        # Pin connected to Ethernet clock module
    mode: CLK_OUT                      # Clock mode: CLK_OUT (internal) or CLK_EXT_IN (external)
  phy_addr: 0                          # (Optional) Address of the Ethernet PHY chip; default is 0
  power_pin: GPIO12                    # (Optional) Pin that controls Ethernet power/reset

  manual_ip:                           # (Optional) Set a static IP instead of DHCP
    static_ip: 192.168.1.42            # IP address for this device
    gateway: 192.168.1.1               # Gateway (usually your router)
    subnet: 255.255.255.0              # Subnet mask, normally 255.255.255.0
    dns1: 8.8.8.8                      # (Optional) Primary DNS server
    dns2: 1.1.1.1                      # (Optional) Secondary DNS server

  mac_address: "AA:BB:CC:DD:EE:FF"     # (Optional) Custom MAC address for the interface
  domain: ".local"                     # (Optional) mDNS or upload domain, default: ".local"
  use_address: 192.168.1.42            # (Optional) Override IP for OTA uploads or Home Assistant

  id: my_eth_interface                 # (Optional) Internal reference ID

  phy_registers:                       # (Optional) Custom register overrides for the PHY (advanced)
    - address: 0x10                    # Register address in hexadecimal
      value: 0x1FFA                    # Value for this register
      page_id: 0x07                    # (Optional) Page to select before writing (RTL8201 only)
]]></YAML>
</Component>

<Component>
  <Name>esp32_hosted</Name>
  <Category>Hardware</Category>
  <Description>ESP-Hosted co-processor configuration: use an ESP32 module as a network (Wi-Fi / BT) co-processor for a host MCU.</Description>
  <YAML><![CDATA[
esp32_hosted:                         # https://www.esphome.io/components/esp32_hosted/
  variant: ESP32C6                    # ESP32 co-processor variant (e.g. ESP32, ESP32S2, ESP32S3, ESP32C2, ESP32C3, ESP32C6)
  reset_pin: GPIOXX                   # Pin used to reset the co-processor
  cmd_pin: GPIOXX                     # Pin for command/data signaling (see board reference)
  clk_pin: GPIOXX                     # Pin for clock signal if required (refer to hardware)
  d0_pin: GPIOXX                      # Data line 0 (use hardware guidelines for pinout)
  d1_pin: GPIOXX                      # Data line 1
  d2_pin: GPIOXX                      # Data line 2
  d3_pin: GPIOXX                      # Data line 3
  active_high: true                   # If true, co-processor is active when reset pin is high (otherwise, when low)
  phy_addr: 1                         # (Optional) PHY address, if multiple chips may need configuration
  id: my_esp32_hosted                 # (Optional) Internal reference name for this hosted interface

  wifi:                               # Wireless configuration for the hosted ESP32 co-processor
    ssid: !secret wifi_ssid           # WiFi SSID for the network
    password: !secret wifi_password   # WiFi Password for the network

# Additional advanced options (if needed)

  manual_ip:                          # (Optional) Static IP configuration for the wireless interface
    static_ip: 192.168.1.42           # Device IP address to assign
    gateway: 192.168.1.1              # Gateway router address
    subnet: 255.255.255.0             # Network subnet mask
    dns1: 8.8.8.8                     # (Optional) Primary DNS server
    dns2: 1.1.1.1                     # (Optional) Secondary DNS server

  mac_address: "AA:BB:CC:DD:EE:FF"    # (Optional) Custom MAC address for ESP32 Hosted chip

  domain: ".local"                    # (Optional) mDNS domain for network discovery, default ".local"
  use_address: 192.168.1.42           # (Optional) Override the address used for integration or OTA

  on_connect:                         # (Optional) Automations for successful connection
    then:
      - logger.log: "ESP32 Hosted is connected!"

  on_disconnect:                      # (Optional) Automations for lost connection
    then:
      - logger.log: "ESP32 Hosted was disconnected!"
]]></YAML>
</Component>

<Component>
  <Name>openthread</Name>
  <Category>Network</Category>
  <Description>Configuration for Thread networking using OpenThread on ESPHome devices (e.g. ESP32-C6, ESP32-H2).</Description>
  <YAML><![CDATA[
openthread:                           # https://esphome.io/components/openthread.html
  device_type: FTD                     # Thread device type: FTD (Full Thread Device) or MTD (Minimal Thread Device)
  channel: 13                          # Thread channel (11-26)
  network_name: "OpenThread-Network"   # Human-readable network name
  network_key: 0x0123456789abcdef0123456789abcdef  # 16-byte network key
  pan_id: 0x1234                       # 2-byte PAN ID
  ext_pan_id: 0x1122334455667788       # 8-byte Extended PAN ID
  pskc: 0xaabbccddeeff001122334455667788  # PSKc for commissioner authentication (optional)
  mesh_local_prefix: "fd00:1234:5678:9abc::/64"  # IPv6 mesh-local prefix
  
  force_dataset: true                  # Force your dataset rather than using defaults  
                                        # (useful when migrating or controlling dataset manually)

  # Alternatively, you can provide full TLV dataset from Home Assistant (e.g., via Thread Commissioning):
  # tlv: "0e08000000000001000000030000..."  # Full Thread Dataset TLV as hex string

  # Optional: callback for factory reset (if you want to reset Thread config on device)
  on_factory_reset:
    then:
      - lambda: |-
          ESP_LOGW("openthread", "Factory reset triggered");  
          id(openthread_component).defer_factory_reset_external_callback();

  id: openthread_component              # Optional identifier to reference this component
]]></YAML>
</Component>

<Component>
  <Name>api</Name>
  <Category>Communication</Category>
  <Description>Native API for direct communication between ESPHome devices and Home Assistant, including encryption, services, and callbacks.</Description>
  <YAML><![CDATA[
api:                                  # https://esphome.io/components/api.html
  id: api_component                    # Optional identifier
  port: 6053                           # Default port for ESPHome Native API
  password: !secret api_password       # (Optional) password for protecting API access
  encryption:
    key: !secret api_encryption_key    # 16-byte key (Base64 encoded) for secure communication
  reboot_timeout: 0s                   # Disable auto-reboot if API disconnected (0s = disabled)
  debug: false                         # Enable low-level API message logging
  services:
    - service: set_led_brightness
      variables:
        brightness: int
      then:
        - logger.log: "Setting LED brightness from API"
        - lambda: |-
            id(my_led).set_level(brightness / 100.0f);

    - service: reboot_device
      then:
        - logger.log: "Reboot requested via API"
        - button.press: restart_button

  on_client_connected:
    - logger.log: "Home Assistant connected to device"
  on_client_disconnected:
    - logger.log: "Home Assistant disconnected"
]]></YAML>
</Component>

<Component>
  <Name>mqtt</Name>
  <Category>Communication</Category>
  <Description>MQTT client configuration for ESPHome devices, enabling communication via an external MQTT broker.</Description>
  <YAML><![CDATA[
mqtt:                                 # https://esphome.io/components/mqtt.html
  broker: 192.168.1.10                # MQTT broker address (IP or hostname)
  port: 1883                          # Default MQTT port
  username: !secret mqtt_user         # Optional username
  password: !secret mqtt_pass         # Optional password
  client_id: esphome_device           # MQTT client identifier
  topic_prefix: my_device             # Prefix for all MQTT topics
  discovery: true                     # Enable MQTT discovery for Home Assistant
  birth_message:
    topic: esphome/lifecycle
    payload: "online"                 # Message when the device boots
    qos: 1
  will_message:
    topic: esphome/lifecycle
    payload: "offline"                # Message when the device disconnects unexpectedly
    qos: 1
    retain: false
  log_topic: esphome/logs             # Publish device logs to MQTT
  keepalive: 15s                      # Keepalive interval
  reboot_timeout: 0s                  # Disable auto-reboot on MQTT disconnect
  on_message:
    - topic: esphome/command/restart  # Custom MQTT command
      then:
        - button.press: restart_button
  id: mqtt_component                  # Internal identifier
]]></YAML>
</Component>

<Component>
  <Name>esp_now</Name>
  <Category>Communication</Category>
  <Description>ESP-NOW peer-to-peer wireless communication for ESPHome devices, enabling low-latency and connectionless messaging.</Description>
  <YAML><![CDATA[
esp_now:                              # https://esphome.io/components/esp_now.html
  wifi_channel: 6                     # WiFi/ESP-NOW must operate on the same channel
  enable_wake_from_sleep: false       # Allow ESP-NOW to wake device from light sleep (ESP32 only)
  id: espnow_component                # Optional identifier
  encryption:
    key: "00112233445566778899AABBCCDDEEFF"   # 16-byte hex key for secure peer communication
  peers:
    - mac_address: "A4:CF:12:00:11:22"  # MAC of another ESP-NOW device
      channel: 6                        # Must match both devices
      encryption_key: "00112233445566778899AABBCCDDEEFF"
      id: peer_device_1                 # Optional internal reference

    - mac_address: "24:6F:28:AA:BB:CC"
      channel: 6
      id: peer_device_2
  on_receive:
    then:
      - lambda: |-
          ESP_LOGI("esp-now", "Received %d bytes from %s",
            data.size(), mac_address.c_str());
  on_boot:
    priority: -100
    then:
      - esp_now.send:
          peer_id: peer_device_1
          data: "Hello World"
]]></YAML>
</Component>

<Component>
  <Name>http_request</Name>
  <Category>Communication</Category>
  <Description>HTTP client to perform GET, POST, PUT, PATCH or DELETE requests from ESPHome devices.</Description>
  <YAML><![CDATA[
http_request:                         # https://esphome.io/components/http_request.html
  id: http_client                      # Optional identifier
  verify_ssl: false                    # Disable certificate validation (for self-signed HTTPS)
  timeout: 10s                         # Global HTTP request timeout
  useragent: "ESPHome/1.0"
  headers:
    Authorization: "Bearer ABCDEF123456"
    X-Custom-Header: "CustomValue"
on_boot:
  priority: -10
  then:
    - http_request.get:
        url: http://example.com/api/status
        headers:
          Accept: "application/json"
script:
  - id: send_data
    mode: queued
    then:
      - http_request.post:
          url: http://example.com/api/data
          headers:
            Content-Type: "application/json"
          json:
            temperature: !lambda 'return id(temp_sens).state;'
            humidity: !lambda 'return id(hum_sens).state;'
  - id: send_custom_raw
    then:
      - http_request.post:
          url: http://example.com/submit
          body: "raw text message"
  - id: call_webhook
    then:
      - http_request.post:
          url: https://hooks.nabu.casa/.../trigger_event
          json:
            device: "sensor-node"
            status: "online"

]]></YAML>
</Component>


















































<Component>
<Name>YAML Configuration</Name>
<Category>Core</Category>
<Description>Base YAML configuration example.</Description>
<YAML>
<![CDATA[
esphome:
  name: my_device
  platform: ESP32
  board: esp32dev
]]>
</YAML>
</Component>

  <Component>
    <Name>Packages</Name>
    <Category>Core</Category>
    <Description>Uso dei packages per organizzare configurazioni.</Description>
    <YAML><![CDATA[
packages:
  sensors:
    sensor: !include sensors.yaml
]]></YAML>
  </Component>
  <Component>
    <Name>Substitutions</Name>
    <Category>Core</Category>
    <Description>Sostituzioni per parametri riutilizzabili.</Description>
    <YAML><![CDATA[
substitutions:
  device_name: "my_device"
]]></YAML>
  </Component>
  <Component>
    <Name>External Components</Name>
    <Category>Core</Category>
    <Description>Includere componenti esterni (GitHub).</Description>
    <YAML><![CDATA[
external_components:
  - source: github://user/repo
]]></YAML>
  </Component>
  <Component>
    <Name>ESP32</Name>
    <Category>Hardware</Category>
    <Description>Configurazione per microcontroller ESP32.</Description>
    <YAML><![CDATA[
esp32:
  board: esp32dev
]]></YAML>
  </Component>
  <Component>
    <Name>ESP8266</Name>
    <Category>Hardware</Category>
    <Description>Configurazione per microcontroller ESP8266.</Description>
    <YAML><![CDATA[
esp8266:
  board: nodemcuv2
]]></YAML>
  </Component>
  <Component>
    <Name>RP2040</Name>
    <Category>Hardware</Category>
    <Description>Configurazione per RP2040 (Raspberry Pico / RP2040).</Description>
    <YAML><![CDATA[
rp2040:
  board: pico
]]></YAML>
  </Component>
  <Component>
    <Name>BK7231/ BK72xx</Name>
    <Category>Hardware</Category>
    <Description>Supporto per SoC Beken (dove disponibile).</Description>
    <YAML><![CDATA[
# bk72xx specific config example
]]></YAML>
  </Component>
  <Component>
    <Name>RTL8720</Name>
    <Category>Hardware</Category>
    <Description>Supporto RTL8720 microcontroller (dove disponibile).</Description>
    <YAML><![CDATA[
# rtl8720 specific config example
]]></YAML>
  </Component>
  <Component>
    <Name>LN882x</Name>
    <Category>Hardware</Category>
    <Description>Supporto LN882x microcontrollers (dove disponibile).</Description>
    <YAML><![CDATA[
# ln882x specific config example
]]></YAML>
  </Component>
  <Component>
    <Name>Host</Name>
    <Category>Hardware</Category>
    <Description>Modalità host (es. eseguire su sistema host per test).</Description>
    <YAML><![CDATA[
# host platform example
]]></YAML>
  </Component>
  <Component>
    <Name>NRF52</Name>
    <Category>Hardware</Category>
    <Description>Supporto Nordic nRF52 microcontrollers.</Description>
    <YAML><![CDATA[
# nrf52 specific config example
]]></YAML>
  </Component>
  <Component>
    <Name>PSRAM</Name>
    <Category>Hardware</Category>
    <Description>Configurazione e abilitazione PSRAM (ESP32).</Description>
    <YAML><![CDATA[
esp32:
  psram: true
]]></YAML>
  </Component>
  <Component>
    <Name>Deep Sleep</Name>
    <Category>Power</Category>
    <Description>Esempio deep_sleep per risparmio energetico.</Description>
    <YAML><![CDATA[
deep_sleep:
  run_duration: 10s
  sleep_duration: 10min
]]></YAML>
  </Component>
  <Component>
    <Name>ESP32-P4 LDO regulator</Name>
    <Category>Hardware</Category>
    <Description>Impostazioni specifiche regolatore LDO su ESP32-P4.</Description>
    <YAML><![CDATA[
# esp32-p4 regulator example
]]></YAML>
  </Component>
  <Component>
    <Name>Automations Overview</Name>
    <Category>Automation</Category>
    <Description>Esempio base di automazioni (trigger/condition/action).</Description>
    <YAML><![CDATA[
automation:
  - alias: "When pressed, toggle light"
    trigger:
      - platform: gpio
        pin: GPIO0
        rising_edge: true
    action:
      - switch.toggle: relay1
]]></YAML>
  </Component>
  <Component>
    <Name>Actions, Triggers, Conditions</Name>
    <Category>Automation</Category>
    <Description>Esempi di azioni, trigger e condizioni.</Description>
    <YAML><![CDATA[
# trigger / condition / action example
]]></YAML>
  </Component>
  <Component>
    <Name>Templates</Name>
    <Category>Automation</Category>
    <Description>Uso di template e lambda per logica personalizzata.</Description>
    <YAML><![CDATA[
sensor:
  - platform: template
    name: "Computed"
    lambda: |-
      return id(temp_sensor).state + 1.0;
]]></YAML>
  </Component>
  <Component>
    <Name>Core</Name>
    <Category>Core</Category>
    <Description>Componenti core (esphome, name, platform).</Description>
    <YAML><![CDATA[
esphome:
  name: example
]]></YAML>
  </Component>
  <Component>
    <Name>Captive Portal</Name>
    <Category>Network</Category>
    <Description>Captive portal per configurazione WiFi.</Description>
    <YAML><![CDATA[
captive_portal:
]]></YAML>
  </Component>
  <Component>
    <Name>Copy</Name>
    <Category>Utility</Category>
    <Description>Azione per copiare valori (es. to clipboard).</Description>
    <YAML><![CDATA[
# copy action example
]]></YAML>
  </Component>
  <Component>
    <Name>Demo</Name>
    <Category>Utility</Category>
    <Description>Esempi demo per sviluppo e test.</Description>
    <YAML><![CDATA[
# demo config
]]></YAML>
  </Component>
  <Component>
    <Name>Globals</Name>
    <Category>Core</Category>
    <Description>Variabili globali condivise tra componenti.</Description>
    <YAML><![CDATA[
globals:
  - id: my_counter
    type: int
    restore_value: yes
    initial_value: '0'
]]></YAML>
  </Component>
  <Component>
    <Name>Improv via BLE</Name>
    <Category>Integration</Category>
    <Description>Improv via BLE per provisioning/gestione.</Description>
    <YAML><![CDATA[
improv_ble:
]]></YAML>
  </Component>
  <Component>
    <Name>Improv via Serial</Name>
    <Category>Integration</Category>
    <Description>Improv via serial per provisioning/gestione.</Description>
    <YAML><![CDATA[
improv_serial:
]]></YAML>
  </Component>
  <Component>
    <Name>Interval</Name>
    <Category>Utility</Category>
    <Description>Trigger periodici con interval.</Description>
    <YAML><![CDATA[
interval:
  - interval: 60s
    then:
      - logger.log: "Tick"
]]></YAML>
  </Component>
  <Component>
    <Name>JSON</Name>
    <Category>Utility</Category>
    <Description>Supporto JSON per esportazione o parsing.</Description>
    <YAML><![CDATA[
# json example
]]></YAML>
  </Component>
  <Component>
    <Name>Mapping</Name>
    <Category>Utility</Category>
    <Description>Map valori o configurazioni.</Description>
    <YAML><![CDATA[
# mapping example
]]></YAML>
  </Component>
  <Component>
    <Name>XXTEA</Name>
    <Category>Security</Category>
    <Description>Crittografia XXTEA per payload.</Description>
    <YAML><![CDATA[
xxtea:
  key: "base64:xxxxxxxx"
]]></YAML>
  </Component>
  <Component>
    <Name>Script</Name>
    <Category>Automation</Category>
    <Description>Script riutilizzabili con azioni.</Description>
    <YAML><![CDATA[
script:
  - id: boot_script
    then:
      - logger.log: "Boot script running"
]]></YAML>
  </Component>
  <Component>
    <Name>Factory Reset</Name>
    <Category>Utility</Category>
    <Description>Procedura per reset di fabbrica via componente.</Description>
    <YAML><![CDATA[
button:
  - platform: factory_reset
    name: "Factory Reset"
]]></YAML>
  </Component>
  <Component>
    <Name>WiFi</Name>
    <Category>Network</Category>
    <Description>Configurazione WiFi (SSID / password / manual_ip).</Description>
    <YAML><![CDATA[
wifi:
  ssid: "YOUR_SSID"
  password: "YOUR_PASS"
]]></YAML>
  </Component>
  <Component>
    <Name>ESP32 Ethernet</Name>
    <Category>Network</Category>
    <Description>Configurazione Ethernet su ESP32 (MACPHY/W5500 ecc.).</Description>
    <YAML><![CDATA[
ethernet:
  type: LAN8720
]]></YAML>
  </Component>
  <Component>
    <Name>ESP32 Hosted</Name>
    <Category>Network</Category>
    <Description>Modalità hosted per ESP32 (es. hosted network).</Description>
    <YAML><![CDATA[
# esp32 hosted example
]]></YAML>
  </Component>
  <Component>
    <Name>OpenThread</Name>
    <Category>Network</Category>
    <Description>OpenThread support (Thread network).</Description>
    <YAML><![CDATA[
# openthread example
]]></YAML>
  </Component>
  <Component>
    <Name>Network Core</Name>
    <Category>Network</Category>
    <Description>Impostazioni core di rete.</Description>
    <YAML><![CDATA[
# network core example
]]></YAML>
  </Component>
  <Component>
    <Name>Native API</Name>
    <Category>Integration</Category>
    <Description>API nativa ESPHome per integrazione Home Assistant.</Description>
    <YAML><![CDATA[
api:
  password: "api_pass"
]]></YAML>
  </Component>
  <Component>
    <Name>MQTT</Name>
    <Category>Integration</Category>
    <Description>Configurazione broker MQTT.</Description>
    <YAML><![CDATA[
mqtt:
  broker: "192.168.1.10"
]]></YAML>
  </Component>
  <Component>
    <Name>ESP-NOW</Name>
    <Category>Network</Category>
    <Description>ESP-NOW comunicazione tra dispositivi ESP.</Description>
    <YAML><![CDATA[
espnow:
]]></YAML>
  </Component>
  <Component>
    <Name>HTTP Request</Name>
    <Category>Network</Category>
    <Description>Eseguire richieste HTTP da dispositivo.</Description>
    <YAML><![CDATA[
http_request:
  useragent: esphome
]]></YAML>
  </Component>
  <Component>
    <Name>mDNS</Name>
    <Category>Network</Category>
    <Description>Annuncio servizio mDNS per discovery.</Description>
    <YAML><![CDATA[
mdns:
]]></YAML>
  </Component>
  <Component>
    <Name>WireGuard</Name>
    <Category>Network</Category>
    <Description>Integrazione WireGuard per rete sicura.</Description>
    <YAML><![CDATA[
# wireguard example
]]></YAML>
  </Component>
  <Component>
    <Name>StatsD</Name>
    <Category>Network</Category>
    <Description>Invio metriche a StatsD.</Description>
    <YAML><![CDATA[
statsd:
  host: 192.168.1.5
]]></YAML>
  </Component>
  <Component>
    <Name>UDP</Name>
    <Category>Network</Category>
    <Description>Invio/ricerca pacchetti UDP personalizzati.</Description>
    <YAML><![CDATA[
# udp example
]]></YAML>
  </Component>
  <Component>
    <Name>Packet Transport</Name>
    <Category>Network</Category>
    <Description>Meccanismi di trasporto pacchetti riutilizzabili.</Description>
    <YAML><![CDATA[
# packet transport example
]]></YAML>
  </Component>
  <Component>
    <Name>ESP32 BLE Beacon</Name>
    <Category>Bluetooth</Category>
    <Description>Invio beacon BLE (iBeacon / Eddystone).</Description>
    <YAML><![CDATA[
esp32_ble_beacon:
  manufacturer_id: 0xFFFF
]]></YAML>
  </Component>
  <Component>
    <Name>ESP32 BLE Client</Name>
    <Category>Bluetooth</Category>
    <Description>Client BLE per connettersi a periferiche BLE.</Description>
    <YAML><![CDATA[
ble_client:
  - mac_address: AA:BB:CC:DD:EE:FF
]]></YAML>
  </Component>
  <Component>
    <Name>ESP32 BLE Tracker</Name>
    <Category>Bluetooth</Category>
    <Description>Scanner BLE per tracciare device nelle vicinanze.</Description>
    <YAML><![CDATA[
esp32_ble_tracker:
]]></YAML>
  </Component>
  <Component>
    <Name>ESP32 BLE Server</Name>
    <Category>Bluetooth</Category>
    <Description>Server BLE per esporre servizi personalizzati.</Description>
    <YAML><![CDATA[
ble_server:
]]></YAML>
  </Component>
  <Component>
    <Name>Bluetooth Proxy</Name>
    <Category>Bluetooth</Category>
    <Description>Proxy per inoltrare dati BLE a Home Assistant.</Description>
    <YAML><![CDATA[
bluetooth_proxy:
]]></YAML>
  </Component>
  <Component>
    <Name>Improv via BLE</Name>
    <Category>Bluetooth</Category>
    <Description>Provisioning / Improv via BLE.</Description>
    <YAML><![CDATA[
improv_ble:
]]></YAML>
  </Component>
  <Component>
    <Name>Debug</Name>
    <Category>Monitoring</Category>
    <Description>Debugging seriale e output diagnostico.</Description>
    <YAML><![CDATA[
# debug example
]]></YAML>
  </Component>
  <Component>
    <Name>Logger</Name>
    <Category>Monitoring</Category>
    <Description>Configurazione logger (livello, output).</Description>
    <YAML><![CDATA[
logger:
  level: DEBUG
]]></YAML>
  </Component>
  <Component>
    <Name>Syslog</Name>
    <Category>Monitoring</Category>
    <Description>Invio log a server syslog.</Description>
    <YAML><![CDATA[
syslog:
  host: 192.168.1.50
]]></YAML>
  </Component>
  <Component>
    <Name>Prometheus</Name>
    <Category>Monitoring</Category>
    <Description>Esposizione metriche per Prometheus.</Description>
    <YAML><![CDATA[
prometheus:
  enable: true
]]></YAML>
  </Component>
  <Component>
    <Name>Safe Mode</Name>
    <Category>Utility</Category>
    <Description>Modalità sicura per ripristino in caso di errori.</Description>
    <YAML><![CDATA[
safe_mode:
]]></YAML>
  </Component>
  <Component>
    <Name>Web Server</Name>
    <Category>Monitoring</Category>
    <Description>Semplice web server integrato per debug / status.</Description>
    <YAML><![CDATA[
web_server:
  port: 80
]]></YAML>
  </Component>
  <Component>
    <Name>ESP32 Camera Web Server</Name>
    <Category>Monitoring</Category>
    <Description>Web server per streaming camera su ESP32-CAM.</Description>
    <YAML><![CDATA[
esp32_camera:
  name: "Camera"
]]></YAML>
  </Component>
  <Component>
    <Name>OTA Core</Name>
    <Category>Update</Category>
    <Description>Abilitazione OTA.</Description>
    <YAML><![CDATA[
ota:
  password: "ota_password"
]]></YAML>
  </Component>
  <Component>
    <Name>OTA Updates via HTTP Request</Name>
    <Category>Update</Category>
    <Description>Aggiornamenti OTA innescati da chiamate HTTP.</Description>
    <YAML><![CDATA[
ota:
  safe_mode: true
]]></YAML>
  </Component>
  <Component>
    <Name>Update Core / Managed Updates</Name>
    <Category>Update</Category>
    <Description>Entità di gestione aggiornamenti e aggiornamenti gestiti.</Description>
    <YAML><![CDATA[
update:
  - platform: ota
    name: "OTA Update"
]]></YAML>
  </Component>
  <Component>
    <Name>1-Wire</Name>
    <Category>Bus</Category>
    <Description>Bus 1-Wire per sensori Dallas.</Description>
    <YAML><![CDATA[
one_wire:
  # pin: GPIO4
]]></YAML>
  </Component>
  <Component>
    <Name>CAN Bus</Name>
    <Category>Bus</Category>
    <Description>Interfaccia CAN (ESP32 CAN support).</Description>
    <YAML><![CDATA[
canbus:
  # example configuration
]]></YAML>
  </Component>
  <Component>
    <Name>I²C Bus</Name>
    <Category>Bus</Category>
    <Description>Configurazione bus I2C e scansione.</Description>
    <YAML><![CDATA[
i2c:
  sda: GPIO21
  scl: GPIO22
  scan: true
]]></YAML>
  </Component>
  <Component>
    <Name>I²S Audio</Name>
    <Category>Bus</Category>
    <Description>Interfaccia I²S per audio / microfono / speaker.</Description>
    <YAML><![CDATA[
i2s:
  mck_pin: GPIO0
]]></YAML>
  </Component>
  <Component>
    <Name>OpenTherm</Name>
    <Category>Bus</Category>
    <Description>Protocollo OpenTherm per caldaie/termostati.</Description>
    <YAML><![CDATA[
opentherm:
  # opentherm example
]]></YAML>
  </Component>
  <Component>
    <Name>SPI Bus</Name>
    <Category>Bus</Category>
    <Description>Configurazione bus SPI.</Description>
    <YAML><![CDATA[
spi:
  clk_pin: GPIO18
  mosi_pin: GPIO23
  miso_pin: GPIO19
]]></YAML>
  </Component>
  <Component>
    <Name>UART</Name>
    <Category>Bus</Category>
    <Description>Configurazione seriale UART (tx/rx).</Description>
    <YAML><![CDATA[
uart:
  tx_pin: GPIO1
  rx_pin: GPIO3
  baud_rate: 9600
]]></YAML>
  </Component>
  <Component>
    <Name>USB Host</Name>
    <Category>Bus</Category>
    <Description>Supporto USB Host (quando disponibile).</Description>
    <YAML><![CDATA[
# usb_host example
]]></YAML>
  </Component>
  <Component>
    <Name>USB UART</Name>
    <Category>Bus</Category>
    <Description>Interfaccia USB ↔ UART.</Description>
    <YAML><![CDATA[
# usb_uart example
]]></YAML>
  </Component>
  <Component>
    <Name>CH422G</Name>
    <Category>Expander</Category>
    <Description>I/O expander CH422G (esempio).</Description>
    <YAML><![CDATA[
# ch422g example
]]></YAML>
  </Component>
  <Component>
    <Name>MAX6956 (I²C)</Name>
    <Category>Expander</Category>
    <Description>Expander / display driver MAX6956 via I2C.</Description>
    <YAML><![CDATA[
# max6956 example
]]></YAML>
  </Component>
  <Component>
    <Name>MCP23017</Name>
    <Category>Expander</Category>
    <Description>MCP23x I/O expander via I2C.</Description>
    <YAML><![CDATA[
mcp23017:
  - id: mcp1
    address: 0x20
]]></YAML>
  </Component>
  <Component>
    <Name>MCP23SXX (SPI)</Name>
    <Category>Expander</Category>
    <Description>MCP23Sxx expander via SPI.</Description>
    <YAML><![CDATA[
# mcp23sxx example
]]></YAML>
  </Component>
  <Component>
    <Name>PCA6416A</Name>
    <Category>Expander</Category>
    <Description>PCA6416A I/O expander via I2C.</Description>
    <YAML><![CDATA[
# pca6416a example
]]></YAML>
  </Component>
  <Component>
    <Name>PCA9554</Name>
    <Category>Expander</Category>
    <Description>PCA9554 I/O expander.</Description>
    <YAML><![CDATA[
# pca9554 example
]]></YAML>
  </Component>
  <Component>
    <Name>PCF8574</Name>
    <Category>Expander</Category>
    <Description>PCF8574 I/O expander via I2C.</Description>
    <YAML><![CDATA[
pcf8574:
  - id: pcf1
    address: 0x20
]]></YAML>
  </Component>
  <Component>
    <Name>PI4IOE5V6408</Name>
    <Category>Expander</Category>
    <Description>Expander I/O PI4IOE5V6408 (esempio).</Description>
    <YAML><![CDATA[
# pi4ioe5v6408 example
]]></YAML>
  </Component>
  <Component>
    <Name>SN74HC165</Name>
    <Category>Expander</Category>
    <Description>Shift register SN74HC165 per input a cascata.</Description>
    <YAML><![CDATA[
# sn74hc165 example
]]></YAML>
  </Component>
  <Component>
    <Name>SN74HC595</Name>
    <Category>Expander</Category>
    <Description>Shift register SN74HC595 per output a cascata.</Description>
    <YAML><![CDATA[
# sn74hc595 example
]]></YAML>
  </Component>
  <Component>
    <Name>SX1509</Name>
    <Category>Expander</Category>
    <Description>SX1509 I/O expander / LED driver via I2C.</Description>
    <YAML><![CDATA[
# sx1509 example
]]></YAML>
  </Component>
  <Component>
    <Name>TCA9548A (I²C Multiplexer)</Name>
    <Category>Expander</Category>
    <Description>Multiplexer I2C TCA9548A.</Description>
    <YAML><![CDATA[
# tca9548a example
]]></YAML>
  </Component>
  <Component>
    <Name>TCA9555</Name>
    <Category>Expander</Category>
    <Description>TCA9555 I/O expander.</Description>
    <YAML><![CDATA[
# tca9555 example
]]></YAML>
  </Component>
  <Component>
    <Name>WeiKai SPI/I²C UART/IO Expander</Name>
    <Category>Expander</Category>
    <Description>Expander/bridge multipurpose WeiKai device.</Description>
    <YAML><![CDATA[
# weikai example
]]></YAML>
  </Component>
  <Component>
    <Name>XL9535</Name>
    <Category>Expander</Category>
    <Description>XL9535 I/O expander.</Description>
    <YAML><![CDATA[
# xl9535 example
]]></YAML>
  </Component>
  <Component>
    <Name>DS2484</Name>
    <Category>1-Wire</Category>
    <Description>Controller I2C-to-1Wire DS2484.</Description>
    <YAML><![CDATA[
# ds2484 example
]]></YAML>
  </Component>
  <Component>
    <Name>GPIO (1-Wire)</Name>
    <Category>1-Wire</Category>
    <Description>Uso GPIO per bus 1-wire (one_wire + dallas_temp).</Description>
    <YAML><![CDATA[
one_wire:
  - pin: GPIO4
]]></YAML>
  </Component>
  <Component>
    <Name>ESP32 CAN</Name>
    <Category>CAN</Category>
    <Description>Supporto CAN su ESP32 (SJA1000/MCP25625 stack).</Description>
    <YAML><![CDATA[
canbus:
  rx_pin: GPIO4
  tx_pin: GPIO5
]]></YAML>
  </Component>
  <Component>
    <Name>MCP2515 (CAN)</Name>
    <Category>CAN</Category>
    <Description>Controller CAN MCP2515 via SPI.</Description>
    <YAML><![CDATA[
mcp2515:
  cs_pin: GPIO15
]]></YAML>
  </Component>
  <Component>
    <Name>Sensor Core</Name>
    <Category>Sensor</Category>
    <Description>Struttura base per sensori (es. platform: sensor).</Description>
    <YAML><![CDATA[
sensor:
  - platform: wifi_signal
    name: "WiFi Signal"
]]></YAML>
  </Component>
  <Component>
    <Name>Template Sensor</Name>
    <Category>Sensor</Category>
    <Description>Sensor calcolato tramite lambda/template.</Description>
    <YAML><![CDATA[
sensor:
  - platform: template
    name: "Template Sensor"
    lambda: |-
      return id(sensor1).state + id(sensor2).state;
]]></YAML>
  </Component>
  <Component>
    <Name>Home Assistant Sensor</Name>
    <Category>Sensor</Category>
    <Description>Sensor legato a entità Home Assistant.</Description>
    <YAML><![CDATA[
sensor:
  - platform: homeassistant
    id: ha_temp
    entity_id: sensor.home_temperature
]]></YAML>
  </Component>
  <Component>
    <Name>MQTT Subscribe Sensor</Name>
    <Category>Sensor</Category>
    <Description>Creare sensori da payload MQTT.</Description>
    <YAML><![CDATA[
sensor:
  - platform: mqtt_subscribe
    name: "MQTT Sensor"
    topic: "home/sensor"
]]></YAML>
  </Component>
  <Component>
    <Name>Uptime Sensor</Name>
    <Category>Sensor</Category>
    <Description>Misura uptime del dispositivo.</Description>
    <YAML><![CDATA[
sensor:
  - platform: uptime
    name: "Uptime"
]]></YAML>
  </Component>
  <Component>
    <Name>WiFi Signal Strength</Name>
    <Category>Sensor</Category>
    <Description>RSSI / livello segnale WiFi.</Description>
    <YAML><![CDATA[
sensor:
  - platform: wifi_signal
    name: "WiFi Signal"
]]></YAML>
  </Component>
  <Component>
    <Name>AGS101</Name>
    <Category>Sensor / Air Quality</Category>
    <Description>Esempio piattaforma AGS101 (VOC).</Description>
    <YAML><![CDATA[
sensor:
  - platform: ags101
    name: "AGS101 VOC"
]]></YAML>
  </Component>
  <Component>
    <Name>CCS811</Name>
    <Category>Sensor / Air Quality</Category>
    <Description>CO2 equivalente e VOC (CCS811).</Description>
    <YAML><![CDATA[
sensor:
  - platform: ccs811
    eco2:
      name: "CCS811 eCO2"
    tvoc:
      name: "CCS811 TVOC"
]]></YAML>
  </Component>
  <Component>
    <Name>MH-Z19</Name>
    <Category>Sensor / Gas</Category>
    <Description>Sensore CO2 MH-Z19 (seriale).</Description>
    <YAML><![CDATA[
sensor:
  - platform: mhz19
    co2:
      name: "MH-Z19 CO2"
]]></YAML>
  </Component>
  <Component>
    <Name>SCD30 / SCD40 / SCD3x</Name>
    <Category>Sensor / CO2</Category>
    <Description>Famiglia sensori SCD per CO2, temperature, umidità.</Description>
    <YAML><![CDATA[
sensor:
  - platform: scd30
    co2:
      name: "SCD30 CO2"
    temperature:
      name: "SCD30 Temp"
]]></YAML>
  </Component>
  <Component>
    <Name>PMS (Plantower) - PMS5003/PMS7003</Name>
    <Category>Sensor / Particulate</Category>
    <Description>Sensori PM (PMSx003 series) tramite seriale.</Description>
    <YAML><![CDATA[
sensor:
  - platform: pmsx003
    pm_2_5:
      name: "PMS PM2.5"
]]></YAML>
  </Component>
  <Component>
    <Name>SDS011</Name>
    <Category>Sensor / Particulate</Category>
    <Description>PM sensor SDS011 via seriale.</Description>
    <YAML><![CDATA[
sensor:
  - platform: sds011
    pm_2_5:
      name: "SDS011 PM2.5"
]]></YAML>
  </Component>
  <Component>
    <Name>SPS30</Name>
    <Category>Sensor / Particulate</Category>
    <Description>SPS30 sensore particolato via I2C/SPI (sensore laser).</Description>
    <YAML><![CDATA[
sensor:
  - platform: sps30
    pm_2_5:
      name: "SPS30 PM2.5"
]]></YAML>
  </Component>
  <Component>
    <Name>ADC (Analog Input)</Name>
    <Category>Sensor / Analog</Category>
    <Description>Ingresso analogico nativo o tramite ADC esterni.</Description>
    <YAML><![CDATA[
sensor:
  - platform: adc
    pin: A0
    name: "Analog Sensor"
]]></YAML>
  </Component>
  <Component>
    <Name>ADS1115</Name>
    <Category>Sensor / ADC</Category>
    <Description>Convertitore ADC ADS1115 (4 canali I2C).</Description>
    <YAML><![CDATA[
sensor:
  - platform: ads1115
    name: "ADS1115 Channel 0"
    channel: 0
]]></YAML>
  </Component>
  <Component>
    <Name>INA219</Name>
    <Category>Sensor / Electricity</Category>
    <Description>Misura corrente/tensione con INA219.</Description>
    <YAML><![CDATA[
sensor:
  - platform: ina219
    shunt_resistance: 0.1 ohm
    bus_voltage:
      name: "INA219 Voltage"
]]></YAML>
  </Component>
  <Component>
    <Name>INA260</Name>
    <Category>Sensor / Electricity</Category>
    <Description>Misura corrente e potenza con INA260.</Description>
    <YAML><![CDATA[
sensor:
  - platform: ina260
    shunt_current:
      name: "INA260 Current"
]]></YAML>
  </Component>
  <Component>
    <Name>BME280</Name>
    <Category>Sensor / Environmental</Category>
    <Description>Temperatura, pressione, umidità via I2C.</Description>
    <YAML><![CDATA[
sensor:
  - platform: bme280
    temperature:
      name: "BME280 Temperature"
    pressure:
      name: "BME280 Pressure"
    humidity:
      name: "BME280 Humidity"
]]></YAML>
  </Component>
  <Component>
    <Name>BMP280</Name>
    <Category>Sensor / Environmental</Category>
    <Description>Temperatura e pressione (BMP280).</Description>
    <YAML><![CDATA[
sensor:
  - platform: bmp280
    temperature:
      name: "BMP280 Temperature"
]]></YAML>
  </Component>
  <Component>
    <Name>HTU21D / Si7021 / SHT21</Name>
    <Category>Sensor / Environmental</Category>
    <Description>Sensori temperatura e umidità digitali (HTU21D / Si7021 / SHT21).</Description>
    <YAML><![CDATA[
sensor:
  - platform: htu21d
    temperature:
      name: "HTU21D Temp"
]]></YAML>
  </Component>
  <Component>
    <Name>DHT</Name>
    <Category>Sensor / Environmental</Category>
    <Description>DHT11/DHT22 sensori temperatura/umidità.</Description>
    <YAML><![CDATA[
sensor:
  - platform: dht
    pin: GPIO4
    temperature:
      name: "DHT Temperature"
]]></YAML>
  </Component>
  <Component>
    <Name>SI7021</Name>
    <Category>Sensor / Environmental</Category>
    <Description>Sensore temperatura/umidità SI7021.</Description>
    <YAML><![CDATA[
sensor:
  - platform: si7021
    name: "SI7021 Temp"
]]></YAML>
  </Component>
  <Component>
    <Name>AM2320</Name>
    <Category>Sensor / Environmental</Category>
    <Description>Sensore AM2320 tramite I2C.</Description>
    <YAML><![CDATA[
sensor:
  - platform: am2320
    name: "AM2320 Temp"
]]></YAML>
  </Component>
  <Component>
    <Name>BH1750</Name>
    <Category>Sensor / Light</Category>
    <Description>Sensore luminosità BH1750 via I2C.</Description>
    <YAML><![CDATA[
sensor:
  - platform: bh1750
    name: "Ambient Light"
]]></YAML>
  </Component>
  <Component>
    <Name>TSL2561</Name>
    <Category>Sensor / Light</Category>
    <Description>Sensore lux TSL2561.</Description>
    <YAML><![CDATA[
sensor:
  - platform: tsl2561
    name: "TSL2561 Lux"
]]></YAML>
  </Component>
  <Component>
    <Name>VL53L0X</Name>
    <Category>Sensor / Distance</Category>
    <Description>Time-of-Flight VL53L0X via I2C.</Description>
    <YAML><![CDATA[
sensor:
  - platform: vl53l0x
    name: "VL53L0X Distance"
]]></YAML>
  </Component>
  <Component>
    <Name>Ultrasonic (HC-SR04)</Name>
    <Category>Sensor / Distance</Category>
    <Description>Sensore ad ultrasuoni (trigger/echo pins).</Description>
    <YAML><![CDATA[
sensor:
  - platform: ultrasonic
    trigger_pin: GPIO5
    echo_pin: GPIO4
    name: "Distance"
]]></YAML>
  </Component>
  <Component>
    <Name>HMC5883L</Name>
    <Category>Sensor / Magnetic</Category>
    <Description>Magnetometro 3-axis HMC5883L.</Description>
    <YAML><![CDATA[
sensor:
  - platform: hmc5883l
    name: "HMC5883L"
]]></YAML>
  </Component>
  <Component>
    <Name>MPU6050</Name>
    <Category>Sensor / Motion</Category>
    <Description>Accelerometro e giroscopio MPU6050 (I2C).</Description>
    <YAML><![CDATA[
sensor:
  - platform: mpu6050
    name: "MPU6050"
]]></YAML>
  </Component>
  <Component>
    <Name>Binary Sensor Core</Name>
    <Category>BinarySensor</Category>
    <Description>Categorie base per binary_sensor.</Description>
    <YAML><![CDATA[
binary_sensor:
  - platform: gpio
    pin: GPIO0
    name: "Door"
]]></YAML>
  </Component>
  <Component>
    <Name>Capacitive Touch (ESP32)</Name>
    <Category>BinarySensor</Category>
    <Description>Touch capacitivo ESP32 touch pads.</Description>
    <YAML><![CDATA[
binary_sensor:
  - platform: esp32_touch
    touch_pin: T0
    name: "Touch"
]]></YAML>
  </Component>
  <Component>
    <Name>PN532</Name>
    <Category>NFC/RFID</Category>
    <Description>Reader PN532 (I2C / SPI / UART) per NFC/RFID.</Description>
    <YAML><![CDATA[
pn532:
  cs_pin: GPIO5
]]></YAML>
  </Component>
  <Component>
    <Name>RC522</Name>
    <Category>NFC/RFID</Category>
    <Description>Reader RC522 via SPI per RFID.</Description>
    <YAML><![CDATA[
mfrc522:
  cs_pin: GPIO15
  reset_pin: GPIO4
]]></YAML>
  </Component>
  <Component>
    <Name>Display Core</Name>
    <Category>Display</Category>
    <Description>Componenti base per displays e rendering.</Description>
    <YAML><![CDATA[
display:
  - platform: ssd1306_i2c
    id: my_display
]]></YAML>
  </Component>
  <Component>
    <Name>SSD1306</Name>
    <Category>Display</Category>
    <Description>OLED SSD1306 via I2C.</Description>
    <YAML><![CDATA[
display:
  - platform: ssd1306_i2c
    model: "SSD1306 128x64"
    address: 0x3C
]]></YAML>
  </Component>
  <Component>
    <Name>ILI9341</Name>
    <Category>Display</Category>
    <Description>Controller TFT ILI9341 via SPI.</Description>
    <YAML><![CDATA[
display:
  - platform: ili9341_spi
    cs_pin: GPIO15
    dc_pin: GPIO2
]]></YAML>
  </Component>
  <Component>
    <Name>Nextion</Name>
    <Category>Display</Category>
    <Description>Display Nextion con controllo via seriale.</Description>
    <YAML><![CDATA[
nextion:
  uart_id: uart1
]]></YAML>
  </Component>
  <Component>
    <Name>NeoPixelBus</Name>
    <Category>Light</Category>
    <Description>Strisce addressable (WS2812) con NeoPixelBus.</Description>
    <YAML><![CDATA[
light:
  - platform: neopixelbus
    type: GRB
    pin: GPIO2
    num_leds: 8
]]></YAML>
  </Component>
  <Component>
    <Name>FastLED</Name>
    <Category>Light</Category>
    <Description>Strisce addressable gestite con FastLED.</Description>
    <YAML><![CDATA[
light:
  - platform: fastled_clockless
    chipset: WS2812
    pin: GPIO3
    num_leds: 16
]]></YAML>
  </Component>
  <Component>
    <Name>LEDC (ESP32 PWM)</Name>
    <Category>Output</Category>
    <Description>Uscita PWM LEDC per ESP32.</Description>
    <YAML><![CDATA[
output:
  - platform: ledc
    pin: GPIO18
    id: pwm_out
]]></YAML>
  </Component>
  <Component>
    <Name>GPIO Output</Name>
    <Category>Output</Category>
    <Description>Uscita digitale semplice su pin GPIO.</Description>
    <YAML><![CDATA[
output:
  - platform: gpio
    pin: GPIO5
    id: relay_out
]]></YAML>
  </Component>
  <Component>
    <Name>Remote Receiver</Name>
    <Category>Remote</Category>
    <Description>Ricevitore IR per decodifica segnali remoti.</Description>
    <YAML><![CDATA[
remote_receiver:
  pin: GPIO15
  dump: all
]]></YAML>
  </Component>
  <Component>
    <Name>Remote Transmitter</Name>
    <Category>Remote</Category>
    <Description>Trasmettitore IR per invio codici remoti.</Description>
    <YAML><![CDATA[
remote_transmitter:
  pin: GPIO4
  carrier_duty_percent: 50%
]]></YAML>
  </Component>
  <Component>
    <Name>SPIFFS / LittleFS</Name>
    <Category>Filesystem</Category>
    <Description>Uso del filesystem onboard per file / logs.</Description>
    <YAML><![CDATA[
# LittleFS / SPIFFS usage depends on board
]]></YAML>
  </Component>
  <Component>
    <Name>External Components</Name>
    <Category>Extension</Category>
    <Description>Includere componenti esterni da repository.</Description>
    <YAML><![CDATA[
external_components:
  - source: github://user/repo
    components: [custom_comp]
]]></YAML>
  </Component>
  <Component>
    <Name>Web Server</Name>
    <Category>Utility</Category>
    <Description>Semplice web server integrato per debug.</Description>
    <YAML><![CDATA[
web_server:
  port: 80
]]></YAML>
  </Component>
  <Component>
    <Name>Template Switch</Name>
    <Category>Switch</Category>
    <Description>Esempio switch con azioni personalizzate.</Description>
    <YAML><![CDATA[
switch:
  - platform: template
    name: "Template Switch"
    turn_on_action:
      - logger.log: "Turned on"
]]></YAML>
  </Component>
  <Component>
    <Name>Template Sensor (example)</Name>
    <Category>Sensor</Category>
    <Description>Esempio sensore template con lambda.</Description>
    <YAML><![CDATA[
sensor:
  - platform: template
    name: "Combined"
    lambda: |-
      return id(sensor_a).state + id(sensor_b).state;
]]></YAML>
  </Component>
  
  
<Component>
<Name>New XML Component</Name>
<Category>XML Template File</Category>
<Description>To create a new empty XML component.</Description>
<YAML><![CDATA[
<Component>
<Name>ComponentName</Name>
<Category>CategoryName</Category>
<Description>ComponentDescription</Description>
<YAML>&lt;![CDATA[
YAML_CODE
]]&gt;</YAML>
</Component>
]]></YAML>
</Component>  
    
</Components>  