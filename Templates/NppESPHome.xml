<Components>

<Component>
  <Name>ESP32</Name>
  <Category>Microcontrollers</Category>
  <Description>ESP32 microcontroller configuration with extended options (board variant, flash size, CPU freq, framework, advanced settings).</Description>
  <YAML><![CDATA[
esp32:                                 # https://www.esphome.io/components/esp32/   
  variant: esp32dev                    # choose the correct variant: esp32, esp32s2, esp32s3, esp32c2, esp32c3, esp32c5, esp32c6, esp32h2 or esp32p4 :contentReference[oaicite:3]{index=3}
  board: esp32dev                      # PlatformIO board ID (optional when variant is used) :contentReference[oaicite:4]{index=4}
  flash_size: 4MB                      # flash size: 2MB, 4MB, 8MB, 16MB, 32MB. Defaults often 4MB. :contentReference[oaicite:5]{index=5}
  cpu_frequency: 160MHz                # CPU frequency: 40MHz, 80MHz, 160MHz, 240MHz, 360MHz, 400MHz depending on variant :contentReference[oaicite:6]{index=6}
  framework:
    type: esp-idf                      # framework type: 'esp-idf' or 'arduino' (ESP-IDF recommended for many variants) :contentReference[oaicite:7]{index=7}
    version: recommended               # 'recommended', 'latest', or 'dev'
    source: default                    # optional custom framework source repository
    platform_version: latest           # optional override of PlatformIO package version
    sdkconfig_options:                 # optional advanced ESP-IDF configuration mapping
      CONFIG_MY_CUSTOM_OPTION: true
    log_level: INFO                    # optional log level: ERROR / NONE / WARN / INFO / DEBUG / VERBOSE
    advanced:                          # advanced settings (ESP-IDF only)
      enable_lwip_dhcp_server: false
      enable_lwip_mdns_queries: false
      enable_lwip_bridge_interface: false
      enable_lwip_tcpip_core_locking: true
      enable_lwip_check_thread_safety: true
      ignore_efuse_custom_mac: false
      ignore_efuse_mac_crc: false             # only for original ESP32 + esp-idf :contentReference[oaicite:8]{index=8}
      execute_from_psram: false               # On certain variants with PSRAM it can be enabled :contentReference[oaicite:9]{index=9}
  safe_mode: true                       # optional: enable safe mode on boot failures
  power_save_mode: none                 # optional: none / light / high
  board_build:
    flash_size: 16MB                    # example: if board has larger flash
    psram_enabled: true                 # optional: enable PSRAM if supported
    cpu_frequency: 240MHz               # example alternative CPU frequency
    build_flags:
      - "-DBOARD_HAS_PSRAM"
      - "-mfix-esp32-psram-cache-issue"
  partitions: partitions.csv            # optional: external file for partition scheme
]]></YAML>
</Component>

<Component>
  <Name>ESP8266</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller ESP8266 configuration with extended options.</Description>
  <YAML><![CDATA[
esp8266:                         # https://www.esphome.io/components/esp8266/
  board: nodemcuv2               # other options: esp01_1m, d1_mini, esp07, esp12e, esp8285, esp_wroom_02, esp210, modwifi
  framework:
    version: recommended         # options: recommended / latest / dev
  restore_from_flash: false      # restore persistent preferences from flash (true/false)
  board_flash_mode: dout         # options: qio / qout / dio / dout
  early_pin_init: true           # initialize GPIOs early (true/false)
  safe_mode: true                # enable safe mode on boot failures
  power_save_mode: none          # WiFi power saving: none / light / high
  board_build:
    flash_size: 1MB              # typical flash sizes: 512KB / 1MB / 2MB / 4MB
    cpu_frequency: 80MHz         # CPU frequency: 80MHz / 160MHz
  framework:
    type: arduino                # available type: arduino
    version: recommended         # or latest / dev
    platform_version: latest     # override PlatformIO core if needed
]]></YAML>
</Component>

<Component>
  <Name>RP2040</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller RP2040 (e.g., Raspberry Pi Pico / Pico W) configuration.</Description>
  <YAML><![CDATA[
rp2040:                          # https://www.esphome.io/components/rp2040/
  board: rpipicow                 # valid option: rpipicow (original Pico W) :contentReference[oaicite:3]{index=3}
  watchdog_timeout: 0s            # optional: reboot if hung longer than this (e.g., "500ms", "2s") :contentReference[oaicite:4]{index=4}
  framework:
    # platform_version is no longer required in newer ESPHome versions :contentReference[oaicite:5]{index=5}
    type: arduino                 # example: use Arduino-framework (if supported)
    version: latest               # optional: 'latest', 'recommended', or specific version
  board_build:
    flash_size: 2MB               # example: typical size (adjust per board)
    cpu_frequency: 133MHz         # example: typical for RP2040 (if applicable)
  safe_mode: true                 # optional: enable safe mode on boot failures
  power_save_mode: none           # optional: power saving mode: none / light / high
]]></YAML>
</Component>

<Component>
  <Name>BK72xx</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller Beken BK72xx (BK7231N/T etc) configuration via LibreTiny platform in ESPHome.</Description>
  <YAML><![CDATA[
bk72xx:                              # https://docs.libretiny.eu/docs/platform/beken-72xx/
  board: generic-bk7231n-qfn32-tuya  # example: choose correct board ID (e.g. generic-bk7231n-qfn32-tuya, generic-bk7231t-…) 
  framework:
    version: recommended             # options: recommended / latest / dev
  # Optional (advanced) parameters:
  family: bk7231n                    # optional if board auto-detects; specify if necessary
  safe_mode: true                    # optional: reboot in safe mode on boot failure
  power_save_mode: none              # optional: none / light / high
]]></YAML>
</Component>

<Component>
  <Name>RTL87xx</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller Realtek RTL87xx (e.g., RTL8710BN / RTL8710BX) configuration via LibreTiny platform.</Description>
  <YAML><![CDATA[
rtl87xx:                           # https://esphome.io/components/libretiny/
  board: generic-rtl8710bn-2mb-788k    # select the correct board ID (e.g. generic-rtl8710bx-4m-980k, generic-rtl8710bn-2mb-468k, etc.)
  framework:
    version: recommended           # options: recommended / latest / dev
    source: libretiny              # optional: specify custom LibreTiny framework source
  family: rtl8710b                 # optional: specify the chip family (rtl8710b, rtl8720c, etc.) if not auto-detected
  safe_mode: true                  # enable safe mode on boot failures
  power_save_mode: none            # WiFi power saving: none / light / high
  board_build:
    flash_size: 2MB                # adjust to your board’s flash capacity
    cpu_frequency: 125MHz          # example CPU frequency
]]></YAML>
</Component>

<Component>
  <Name>LN882x</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller LN882x (e.g., LN882HKI) configuration via LibreTiny platform for ESPHome.</Description>
  <YAML><![CDATA[
ln882x:                               # https://esphome.io/components/libretiny/
  board: generic-ln882hki             # select the correct board ID (e.g. generic-ln882hki, generic-ln882x, etc.)
  framework:
    version: recommended              # options: recommended / latest / dev
    source: libretiny                 # optional: specify a custom LibreTiny framework source
  family: ln882hki                    # optional: specify chip family if not auto-detected
  safe_mode: true                     # enable safe mode on boot failures
  power_save_mode: none               # WiFi power saving: none / light / high
  board_build:
    flash_size: 2MB                   # adjust according to the actual board
    cpu_frequency: 80MHz              # typical CPU frequency (if supported)
]]></YAML>
</Component>

<Component>
  <Name>nRF52</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller nRF52 (Nordic Semiconductor) configuration via ESPHome (Zephyr-based support).</Description>
  <YAML><![CDATA[
nrf52:                                     # https://www.esphome.io/components/nrf52/
  board: adafruit_feather_nrf52840         # valid example board: adafruit_itsybitsy_nrf52840, xiao_ble, … :contentReference[oaicite:3]{index=3}
  bootloader: mcuboot                      # optional: bootloader type, options include mcuboot / adafruit / adafruit_nrf52_sd132 / adafruit_nrf52_sd140_v6 / adafruit_nrf52_sd140_v7 :contentReference[oaicite:4]{index=4}
  # Optional (advanced) parameters:
  safe_mode: true                          # optional: enable safe mode on boot failure
  power_save_mode: none                    # optional: none / light / high
  dfu:
    reset_pin:
      number: P0.14                        # example pin to trigger DFU mode via USB/CDC :contentReference[oaicite:5]{index=5}
      inverted: true
]]></YAML>
</Component>

<Component>
  <Name>PSRAM</Name>
  <Category>Peripherals</Category>
  <Description>External PSRAM (Pseudo-Static RAM) configuration for ESP32 modules/boards.</Description>
  <YAML><![CDATA[
psram:                           # https://esphome.io/components/psram.html
  mode: quad                     # operating mode of PSRAM: 'quad' (default) or 'octal'
  speed: 80MHz                   # PSRAM clock speed: 40MHz (default) / 80MHz / 120MHz (120MHz only with octal mode + experimental) :contentReference[oaicite:3]{index=3}
  enable_ecc: false              # (Optional, bool) Enable ECC (Error Correction Code) for octal mode only. Default: false. :contentReference[oaicite:4]{index=4}
  disabled: false                # (Optional, bool) Don’t try to initialize PSRAM. Useful when board lacks PSRAM or PSRAM lines are used for other hardware. Default: false. :contentReference[oaicite:5]{index=5}

  # Advanced / optional settings:
  # Note: these may require specific board support or ESP-IDF/Arduino flags.
  board_build:
    flash_size: 16MB             # Example: size of external flash memory; adjust per your board (often used alongside PSRAM)
    cpu_frequency: 240MHz        # Example: CPU frequency; change according to board capabilities
  framework:
    type: esp-idf                # Example framework: esp-idf or arduino
    version: latest              # Or specific version, if needed
  platformio_options:
    build_flags:
      - "-DBOARD_HAS_PSRAM"      # Example flag to manually enable PSRAM on boards where it isn't auto-detected :contentReference[oaicite:6]{index=6}
      - "-mfix-esp32-psram-cache-issue"  # Example workaround for some ESP32-S3 boards with PSRAM cache issues :contentReference[oaicite:7]{index=7}
]]></YAML>
</Component>

<Component>
  <Name>deep_sleep</Name>
  <Category>Peripherals</Category>
  <Description>Deep sleep configuration for ESP8266/ESP32 to minimise power consumption.</Description>
  <YAML><![CDATA[
deep_sleep:                            # https://www.esphome.io/components/deep_sleep/              
  id: deep_sleep_1                     # optional identifier for referencing the component
  run_duration: 10s                    # time to run before entering sleep mode
  sleep_duration: 10min                # time to sleep before next wake-up

  # ESP32-specific wake-up options:
  wakeup_pin:
    number: GPIO33                     # RTC-capable pin on ESP32
    mode: INPUT_PULLUP                 # pin mode configuration
    inverted: false                    # wake on HIGH (false) or LOW (true)
  wakeup_pin_mode: IGNORE              # behaviour if pin is already in wake state: IGNORE / KEEP_AWAKE / INVERT_WAKEUP
  touch_wakeup: true                    # enable touchpad wake‐up (ESP32 only)
  esp32_ext1_wakeup:
    pins:
      - number: GPIO13
      - number: GPIO27
    mode: ANY_HIGH                     # mode for EXT1 wake up: ANY_LOW / ANY_HIGH / ALL_LOW

  # Conditional run durations depending on wake-up reason (ESP32 only):
  wakeup_cause_to_run_duration:
    default: 5s                         # run duration if woke by timer or unspecified cause
    gpio_wakeup_reason: 2s             # run duration if wake was caused by GPIO
    touch_wakeup_reason: 3s            # run duration if wake was caused by touchpad

  # Template/automation based entering of deep sleep:
  on_...:
    then:
      - deep_sleep.enter:
          id: deep_sleep_1
          sleep_duration: !lambda "return (lux < 10) ? 30min : 5min;"

      - deep_sleep.prevent: deep_sleep_1   # prevent sleep when certain condition holds
      - deep_sleep.allow: deep_sleep_1     # allow sleep again after prevent

  # Time-based wake up until - only ESP32:
  until: "06:00:00"                     # wake up at specified time of day
  time_id: sntp_time                   # ID of the time component to use for 'until'

  # Notes for ESP8266:
  # On ESP8266 only run_duration and sleep_duration are supported.
  # You must connect GPIO16 (D0) to the RST pin in order to wake from deep sleep.  

]]></YAML>
</Component>

<Component>
  <Name>ESP32-P4 LDO</Name>
  <Category>Peripherals</Category>
  <Description>Configuration for ESP32-P4 series boards using LDO regulator and power settings.</Description>
  <YAML><![CDATA[
esp_ldo:
  - channel: 3          # The channel number of the LDO regulator to configure. Only channels 3 and 4 are supported (1 and 2 are used internally by the chip.)
    voltage: 2.5V       # The desired output voltage - must be in the range 0.5V to 2.7V.
    adjustable: true    # If true, the output voltage can be adjusted at run-time. Defaults to false.
]]></YAML>
</Component>

<Component>
  <Name>ESPHome Core</Name>
  <Category>Core</Category>
  <Description>Main ESPHome configuration for device identity, network, logs and OTA.</Description>
  <YAML><![CDATA[
esphome:                             # https://www.esphome.io/components/esphome/
  name: my_device                    # device name (used in Home Assistant entities)
  friendly_name: "My Device"         # optional friendly name shown in UI
  platform: ESP32                    # choose correct platform: ESP8266 / ESP32 / rtl87xx / bk72xx / rp2040 / etc.
  board: esp32dev                    # optional: PlatformIO board ID if needed

# Logging configuration
logger:
  level: DEBUG                       # DEBUG / INFO / WARN / ERROR / NONE
  baud_rate: 0                       # set to 0 to disable UART logging (use USB only)

# OTA update configuration
ota:
  password: "OTA_PASSWORD"           # password for over-the-air updates
  safe_mode: true                    # enable safe mode fallback if update fails
  num_attempts: 3                    # number of OTA attempts before fallback

# Web server (optional)
web_server:
  port: 80
  include_internal: false            # include internal pages (e.g., logs, device info)
  auth:
    username: admin
    password: "WEB_PASSWORD"

# WiFi configuration (for network connectivity)
wifi:
  ssid: "Your_SSID"
  password: "Your_PASSWORD"
  fast_connect: true                 # skip waiting for network in station mode when available
  ap:
    ssid: "FallbackAP_%s"            # fallback access point if WiFi fails
    password: "AP_PASSWORD"
  manual_ip:
    static_ip: 192.168.1.50
    gateway: 192.168.1.1
    subnet: 255.255.255.0

# API configuration (integration with Home Assistant)
api:
  encryption:
    key: "32_BYTE_BASE64_KEY"        # 32 byte base64 Pre-Shared Key for encryption
  password: "API_PASSWORD"           # deprecated — use key instead
  reboot_timeout: 15min              # timeout after which auto-reboot if no communication

# Time component (optional)
time:
  - platform: homeassistant          # or sntp / rtt
    id: home_time
    timezone: "Europe/Rome"

# Device uptime and status sensor
uptime:
  id: device_uptime

# Status LED (optional)
status_led:
  pin:
    number: GPIO2
    inverted: false
]]></YAML>
</Component>

<Component>
  <Name>captive_portal</Name>
  <Category>Core</Category>
  <Description>Captive portal for connecting WiFi devices without preconfigured credentials.</Description>
  <YAML><![CDATA[
captive_portal:                     # https://esphome.io/components/captive_portal/
  id: captive_portal_main           # optional identifier
]]></YAML>
</Component>

<Component>
  <Name>external_components</Name>
  <Category>System</Category>
  <Description>Support for loading external/custom components into ESPHome.</Description>
  <YAML><![CDATA[
external_components:                        # https://www.esphome.io/components/external_components/
  - source:                                 # define source of the external component
      type: local                           # type of source: 'local' / 'git' / 'url' / 'directory'
      path: components/my_component         # path for 'local' type: relative to config folder
  dependencies:                             # optional list of other components needed
    - sensor                                # if your custom component uses sensor platform
    - switch
  reload: true                              # optional: whether changes should force full reload
]]></YAML>
</Component>

<Component>
  <Name>globals</Name>
  <Category>System</Category>
  <Description>Global variables for storing and sharing values between components and automations.</Description>
  <YAML><![CDATA[
globals:                              # https://esphome.io/components/globals/
  - id: counter_value                 # unique variable identifier
    type: int                         # variable type: int / float / bool / std::string / custom
    restore_value: yes                # restore last value from flash on boot (yes/no)
    initial_value: '0'                # initial value (stringified)
  - id: is_enabled
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: temperature_offset
    type: float
    restore_value: yes
    initial_value: '1.5'
]]></YAML>
</Component>

<Component>
  <Name>interval</Name>
  <Category>Automation</Category>
  <Description>Defines recurring timed actions executed at fixed intervals.</Description>
  <YAML><![CDATA[
interval:                            # https://esphome.io/components/interval.html
  - interval: 10s                    # time between executions (supports s, min, h, ms)
    then:                            # actions to perform every interval
      - logger.log: "10-second interval triggered"
      - lambda: |-
          id(counter_value) += 1;    // example using a global variable
      - switch.turn_on: led_power
      - delay: 1s
      - switch.turn_off: led_power

  - interval: 1min
    then:
      - logger.log:
          level: INFO
          format: "Running periodic task every minute"
      - component.update: my_sensor  # manually triggers sensor reading
]]></YAML>
</Component>

<Component>
  <Name>wifi</Name>
  <Category>Network</Category>
  <Description>WiFi configuration for ESPHome devices, including credentials, static networking, power settings and fallback AP.</Description>
  <YAML><![CDATA[
wifi:                                 # https://www.esphome.io/components/wifi/
  ssid: "MyWiFiNetwork"               # The name (SSID) of the WiFi network to connect to
  password: "MyWiFiPassword"          # The password for your WiFi network; leave blank for open networks
  # For connecting to multiple networks, use the networks: list instead of ssid/password
  # networks:
  #   - ssid: "FirstNetwork"
  #     password: "Password1"
  #   - ssid: "SecondNetwork"
  #     password: "Password2"

  manual_ip:                          # (optional) Set a static IP address instead of using DHCP
    static_ip: 192.168.1.100          # The static IP address to assign to this device
    gateway: 192.168.1.1              # Your router's IP address
    subnet: 255.255.255.0             # Subnet mask, usually 255.255.255.0
    dns1: 8.8.8.8                     # (optional) Primary DNS server
    dns2: 1.1.1.1                     # (optional) Secondary DNS server

  ap:                                 # (optional) Enable fallback Access Point mode
    ssid: "FallbackHotspot"           # SSID for the fallback AP if WiFi connection fails
    password: "FallbackPassword"      # Password for the hotspot; leave empty for an open AP

  power_save_mode: none               # (optional) WiFi power saving mode: none, light, or high
  output_power: 20dB                  # (optional) WiFi transmit power. Default for ESP32/ESP8266 is 20dB
  fast_connect: false                 # (optional) Skip full WiFi scan for faster connection. Use for hidden or single APs
  reboot_timeout: 15min               # (optional) Time to reboot after losing WiFi, default 15min

  on_connect:                         # (optional) Actions when the device connects to WiFi
    then:
      - logger.log: "Connected to WiFi!"

  on_disconnect:                      # (optional) Actions when the device disconnects from WiFi
    then:
      - logger.log: "Disconnected from WiFi!"

  enable_on_boot: true                # (optional) Whether WiFi is enabled at boot. Default is true

  domain: ".local"                    # (optional) mDNS domain to use, default is ".local"
  use_address: 192.168.1.100          # (optional) Override the address used to connect from Home Assistant
 ]]></YAML>
</Component>

<Component>
  <Name>ethernet</Name>
  <Category>Network</Category>
  <Description>Configuration of Ethernet connectivity for ESPHome, including PHY type, pins and network settings.</Description>
  <YAML><![CDATA[
ethernet:                              # https://www.esphome.io/components/ethernet/
  type: LAN8720                        # The Ethernet chip type; options: LAN8720, IP101, RTL8201, W5500, DM9051, OPENETH, LAN8670
  mdc_pin: GPIO23                      # (Required for RMII chips) Pin for MDC signal
  mdio_pin: GPIO18                     # (Required for RMII chips) Pin for MDIO signal
  clk:                                 # (Required for RMII chips) Clock configuration object
    pin: GPIO17                        # Pin connected to Ethernet clock module
    mode: CLK_OUT                      # Clock mode: CLK_OUT (internal) or CLK_EXT_IN (external)
  phy_addr: 0                          # (Optional) Address of the Ethernet PHY chip; default is 0
  power_pin: GPIO12                    # (Optional) Pin that controls Ethernet power/reset

  manual_ip:                           # (Optional) Set a static IP instead of DHCP
    static_ip: 192.168.1.42            # IP address for this device
    gateway: 192.168.1.1               # Gateway (usually your router)
    subnet: 255.255.255.0              # Subnet mask, normally 255.255.255.0
    dns1: 8.8.8.8                      # (Optional) Primary DNS server
    dns2: 1.1.1.1                      # (Optional) Secondary DNS server

  mac_address: "AA:BB:CC:DD:EE:FF"     # (Optional) Custom MAC address for the interface
  domain: ".local"                     # (Optional) mDNS or upload domain, default: ".local"
  use_address: 192.168.1.42            # (Optional) Override IP for OTA uploads or Home Assistant

  id: my_eth_interface                 # (Optional) Internal reference ID

  phy_registers:                       # (Optional) Custom register overrides for the PHY (advanced)
    - address: 0x10                    # Register address in hexadecimal
      value: 0x1FFA                    # Value for this register
      page_id: 0x07                    # (Optional) Page to select before writing (RTL8201 only)
]]></YAML>
</Component>

<Component>
  <Name>esp32_hosted</Name>
  <Category>Hardware</Category>
  <Description>ESP-Hosted co-processor configuration: use an ESP32 module as a network (Wi-Fi / BT) co-processor for a host MCU.</Description>
  <YAML><![CDATA[
esp32_hosted:                         # https://www.esphome.io/components/esp32_hosted/
  variant: ESP32C6                    # ESP32 co-processor variant (e.g. ESP32, ESP32S2, ESP32S3, ESP32C2, ESP32C3, ESP32C6)
  reset_pin: GPIOXX                   # Pin used to reset the co-processor
  cmd_pin: GPIOXX                     # Pin for command/data signaling (see board reference)
  clk_pin: GPIOXX                     # Pin for clock signal if required (refer to hardware)
  d0_pin: GPIOXX                      # Data line 0 (use hardware guidelines for pinout)
  d1_pin: GPIOXX                      # Data line 1
  d2_pin: GPIOXX                      # Data line 2
  d3_pin: GPIOXX                      # Data line 3
  active_high: true                   # If true, co-processor is active when reset pin is high (otherwise, when low)
  phy_addr: 1                         # (Optional) PHY address, if multiple chips may need configuration
  id: my_esp32_hosted                 # (Optional) Internal reference name for this hosted interface

  wifi:                               # Wireless configuration for the hosted ESP32 co-processor
    ssid: !secret wifi_ssid           # WiFi SSID for the network
    password: !secret wifi_password   # WiFi Password for the network

# Additional advanced options (if needed)

  manual_ip:                          # (Optional) Static IP configuration for the wireless interface
    static_ip: 192.168.1.42           # Device IP address to assign
    gateway: 192.168.1.1              # Gateway router address
    subnet: 255.255.255.0             # Network subnet mask
    dns1: 8.8.8.8                     # (Optional) Primary DNS server
    dns2: 1.1.1.1                     # (Optional) Secondary DNS server

  mac_address: "AA:BB:CC:DD:EE:FF"    # (Optional) Custom MAC address for ESP32 Hosted chip

  domain: ".local"                    # (Optional) mDNS domain for network discovery, default ".local"
  use_address: 192.168.1.42           # (Optional) Override the address used for integration or OTA

  on_connect:                         # (Optional) Automations for successful connection
    then:
      - logger.log: "ESP32 Hosted is connected!"

  on_disconnect:                      # (Optional) Automations for lost connection
    then:
      - logger.log: "ESP32 Hosted was disconnected!"
]]></YAML>
</Component>

<Component>
  <Name>openthread</Name>
  <Category>Network</Category>
  <Description>Configuration for Thread networking using OpenThread on ESPHome devices (e.g. ESP32-C6, ESP32-H2).</Description>
  <YAML><![CDATA[
openthread:                           # https://esphome.io/components/openthread.html
  device_type: FTD                     # Thread device type: FTD (Full Thread Device) or MTD (Minimal Thread Device)
  channel: 13                          # Thread channel (11-26)
  network_name: "OpenThread-Network"   # Human-readable network name
  network_key: 0x0123456789abcdef0123456789abcdef  # 16-byte network key
  pan_id: 0x1234                       # 2-byte PAN ID
  ext_pan_id: 0x1122334455667788       # 8-byte Extended PAN ID
  pskc: 0xaabbccddeeff001122334455667788  # PSKc for commissioner authentication (optional)
  mesh_local_prefix: "fd00:1234:5678:9abc::/64"  # IPv6 mesh-local prefix
  
  force_dataset: true                  # Force your dataset rather than using defaults  
                                        # (useful when migrating or controlling dataset manually)

  # Alternatively, you can provide full TLV dataset from Home Assistant (e.g., via Thread Commissioning):
  # tlv: "0e08000000000001000000030000..."  # Full Thread Dataset TLV as hex string

  # Optional: callback for factory reset (if you want to reset Thread config on device)
  on_factory_reset:
    then:
      - lambda: |-
          ESP_LOGW("openthread", "Factory reset triggered");  
          id(openthread_component).defer_factory_reset_external_callback();

  id: openthread_component              # Optional identifier to reference this component
]]></YAML>
</Component>

<Component>
  <Name>api</Name>
  <Category>Communication</Category>
  <Description>Native API for direct communication between ESPHome devices and Home Assistant, including encryption, services, and callbacks.</Description>
  <YAML><![CDATA[
api:                                  # https://esphome.io/components/api.html
  id: api_component                    # Optional identifier
  port: 6053                           # Default port for ESPHome Native API
  password: !secret api_password       # (Optional) password for protecting API access
  encryption:
    key: !secret api_encryption_key    # 16-byte key (Base64 encoded) for secure communication
  reboot_timeout: 0s                   # Disable auto-reboot if API disconnected (0s = disabled)
  debug: false                         # Enable low-level API message logging
  services:
    - service: set_led_brightness
      variables:
        brightness: int
      then:
        - logger.log: "Setting LED brightness from API"
        - lambda: |-
            id(my_led).set_level(brightness / 100.0f);

    - service: reboot_device
      then:
        - logger.log: "Reboot requested via API"
        - button.press: restart_button

  on_client_connected:
    - logger.log: "Home Assistant connected to device"
  on_client_disconnected:
    - logger.log: "Home Assistant disconnected"
]]></YAML>
</Component>

<Component>
  <Name>mqtt</Name>
  <Category>Communication</Category>
  <Description>MQTT client configuration for ESPHome devices, enabling communication via an external MQTT broker.</Description>
  <YAML><![CDATA[
mqtt:                                 # https://esphome.io/components/mqtt.html
  broker: 192.168.1.10                # MQTT broker address (IP or hostname)
  port: 1883                          # Default MQTT port
  username: !secret mqtt_user         # Optional username
  password: !secret mqtt_pass         # Optional password
  client_id: esphome_device           # MQTT client identifier
  topic_prefix: my_device             # Prefix for all MQTT topics
  discovery: true                     # Enable MQTT discovery for Home Assistant
  birth_message:
    topic: esphome/lifecycle
    payload: "online"                 # Message when the device boots
    qos: 1
  will_message:
    topic: esphome/lifecycle
    payload: "offline"                # Message when the device disconnects unexpectedly
    qos: 1
    retain: false
  log_topic: esphome/logs             # Publish device logs to MQTT
  keepalive: 15s                      # Keepalive interval
  reboot_timeout: 0s                  # Disable auto-reboot on MQTT disconnect
  on_message:
    - topic: esphome/command/restart  # Custom MQTT command
      then:
        - button.press: restart_button
  id: mqtt_component                  # Internal identifier
]]></YAML>
</Component>

<Component>
  <Name>esp_now</Name>
  <Category>Communication</Category>
  <Description>ESP-NOW peer-to-peer wireless communication for ESPHome devices, enabling low-latency and connectionless messaging.</Description>
  <YAML><![CDATA[
esp_now:                              # https://esphome.io/components/esp_now.html
  wifi_channel: 6                     # WiFi/ESP-NOW must operate on the same channel
  enable_wake_from_sleep: false       # Allow ESP-NOW to wake device from light sleep (ESP32 only)
  id: espnow_component                # Optional identifier
  encryption:
    key: "00112233445566778899AABBCCDDEEFF"   # 16-byte hex key for secure peer communication
  peers:
    - mac_address: "A4:CF:12:00:11:22"  # MAC of another ESP-NOW device
      channel: 6                        # Must match both devices
      encryption_key: "00112233445566778899AABBCCDDEEFF"
      id: peer_device_1                 # Optional internal reference

    - mac_address: "24:6F:28:AA:BB:CC"
      channel: 6
      id: peer_device_2
  on_receive:
    then:
      - lambda: |-
          ESP_LOGI("esp-now", "Received %d bytes from %s",
            data.size(), mac_address.c_str());
  on_boot:
    priority: -100
    then:
      - esp_now.send:
          peer_id: peer_device_1
          data: "Hello World"
]]></YAML>
</Component>

<Component>
  <Name>http_request</Name>
  <Category>Communication</Category>
  <Description>HTTP client to perform GET, POST, PUT, PATCH or DELETE requests from ESPHome devices.</Description>
  <YAML><![CDATA[
http_request:                         # https://esphome.io/components/http_request.html
  id: http_client                      # Optional identifier
  verify_ssl: false                    # Disable certificate validation (for self-signed HTTPS)
  timeout: 10s                         # Global HTTP request timeout
  useragent: "ESPHome/1.0"
  headers:
    Authorization: "Bearer ABCDEF123456"
    X-Custom-Header: "CustomValue"
on_boot:
  priority: -10
  then:
    - http_request.get:
        url: http://example.com/api/status
        headers:
          Accept: "application/json"
script:
  - id: send_data
    mode: queued
    then:
      - http_request.post:
          url: http://example.com/api/data
          headers:
            Content-Type: "application/json"
          json:
            temperature: !lambda 'return id(temp_sens).state;'
            humidity: !lambda 'return id(hum_sens).state;'
  - id: send_custom_raw
    then:
      - http_request.post:
          url: http://example.com/submit
          body: "raw text message"
  - id: call_webhook
    then:
      - http_request.post:
          url: https://hooks.nabu.casa/.../trigger_event
          json:
            device: "sensor-node"
            status: "online"

]]></YAML>
</Component>

<Component>
  <Name>Factory Reset</Name>
  <Category>Core</Category>
  <Description>Factory reset component to clear all stored ESPHome preferences from flash and reboot the node, with optional fast power‑cycle reset and automation trigger.</Description>
  <YAML><![CDATA[
factory_reset:
  resets_required: 5
  max_delay: 10s
  on_increment:
    - logger.log:
        format: "Fast power cycle count now %u, target %u"
        args: [x, target]

switch:
  - platform: factory_reset
    name: "Factory Reset Switch"

button:
  - platform: factory_reset
    name: "Factory Reset Button"

esp8266:
  restore_from_flash: true
]]></YAML>
</Component>

<Component>
  <Name>Script</Name>
  <Category>Core</Category>
  <Description>Defines a sequence of steps (actions) that can be executed from anywhere in the ESPHome configuration, optionally with parameters and control over concurrent executions.</Description>
  <YAML><![CDATA[
script:
  - id: my_script                 # Script identifier
    mode: restart                 # Behavior if script is executed again while running (single, restart, queued, parallel)
    max_runs: 3                   # Maximum concurrent executions (0 = unlimited)
    parameters:                   # Optional parameters the script can receive (all mandatory if set)
      delay_ms: int
    then:                         # Actions to perform in the script
      - switch.turn_on: my_switch
      - delay: !lambda 'return delay_ms;'
      - switch.turn_off: my_switch
]]></YAML>
</Component>

<Component>
  <Name>Network</Name>
  <Category>Core</Category>
  <Description>Core network settings for ESPHome devices including IPv6 and performance options.</Description>
  <YAML><![CDATA[
network:
  enable_ipv6: true              # Enable IPv6 support
  min_ipv6_addr_count: 2         # Minimum number of IPv6 addresses before network is considered ready
  enable_high_performance: true  # Enable optimizations for higher network performance
]]></YAML>
</Component>

<Component>
  <Name>mDNS</Name>
  <Category>Network</Category>
  <Description>Enables multicast DNS (mDNS) to announce the node on the local network for device discovery by Home Assistant and ESPHome dashboard.</Description>
  <YAML><![CDATA[
mdns:
  disabled: false            # Set to true to disable mDNS (default: false)
  services:                  # Optional list of additional mDNS services to expose
    - service: "_custom_service"    # Service name (required)
      protocol: "_tcp"              # Service protocol: _udp or _tcp (required)
      port: 8080                   # Optional port number
      txt:                         # Optional additional text records
        txt_key_1: "txt_value_1"
]]></YAML>
</Component>

<Component>
  <Name>WireGuard</Name>
  <Category>Network</Category>
  <Description>WireGuard VPN client for ESP32, ESP8266, and BK72xx microcontrollers with custom implementation supporting secure VPN tunnels to a remote peer.</Description>
  <YAML><![CDATA[
wireguard:
  address: x.y.z.w                          # Local VPN IPv4 address (required)
  private_key: AaBbCcDd...=                 # Private key of the device (required)
  peer_endpoint: wg.server.example          # Hostname or IP of remote WireGuard peer (required)
  peer_public_key: EeFfGgHh...=             # Public key of the remote peer (required)

  # Optional parameters
  netmask: 255.255.255.255                  # Netmask for the address (default 255.255.255.255)
  peer_port: 51820                          # UDP port of remote peer (default 51820)
  peer_preshared_key: XxYyZzWw...=         # Pre-shared key for additional encryption layer (optional)
  peer_allowed_ips:                         # List of allowed IPs for peer tunnel access (defaults to device address/32)
    - x.y.z.0/24
    - l.m.n.o/32
  peer_persistent_keepalive: 25s            # Keepalive interval to maintain connection (default 0s disabled)
  
  reboot_timeout: 15min                     # Time to wait before rebooting if peer unreachable (default 15 min)
  require_connection_to_proceed: false      # Wait for connection before proceeding boot (default false)
  update_interval: 10s                      # How often to check connection status (default 10s)
  id: wireguard1                           # Optional ID for code generation
  
# Binary sensors for WireGuard status and enabled state
binary_sensor:
  - platform: wireguard
    status:
      name: "WireGuard Status"
  - platform: wireguard
    enabled:
      name: "WireGuard Enabled"

# Sensor for latest handshake time
sensor:
  - platform: wireguard
    latest_handshake:
      name: "WireGuard Latest Handshake"

# Text sensor exposing the configured WireGuard address
text_sensor:
  - platform: wireguard
    address:
      name: "WireGuard Address"

# Available actions:
# wireguard.disable - disables the VPN link
# wireguard.enable  - enables and starts connection to peer

# Available conditions:
# wireguard.enabled     - checks if WireGuard is enabled
# wireguard.peer_online - checks if remote peer is online
]]></YAML>
</Component>

<Component>
  <Name>StatsD</Name>
  <Category>Networking</Category>
  <Description>StatsD protocol client to send sensor and binary sensor metrics to a StatsD server for aggregation and monitoring.</Description>
  <YAML><![CDATA[
statsd:
  host: REPLACEME                    # IP address of the StatsD server (required)
  port: 8125                        # UDP port of the StatsD server (default 8125)
  prefix: ""                       # Optional prefix to prepend to all metric names
  update_interval: 10s             # How often to send metrics (default 10 seconds)

  sensors:                         # List of sensors to send metrics for (optional)
    - id: some_sensor              # Sensor ID to report
      name: test1.sensor           # Metric name

  binary_sensors:                  # List of binary sensors to send metrics for (optional)
    - id: some_binary_sensor       # Binary sensor ID to report
      name: test1.binary_sensor    # Metric name
]]></YAML>
</Component>

<Component>
  <Name>UDP</Name>
  <Category>Networking</Category>
  <Description>Allows sending and receiving data over the network using the User Datagram Protocol (UDP), including multicast and broadcast support.</Description>
  <YAML><![CDATA[
udp:
  id: udp1                             # Optional ID for the UDP component
  port:
    listen_port: 18511                # Port to listen on for incoming UDP packets (required)
    broadcast_port: 18512             # Port to send UDP packets to (required)
  addresses:                         # Optional list of IP addresses to broadcast data to
    - 255.255.255.255                # Default broadcast address to local network
    - 208.87.135.110
  listen_address: 239.0.60.53        # Optional multicast address to listen to; disables listening on broadcast address if set

# Action to write data to UDP port
on_receive:
  then:
    - logger.log:
        format: "Received %s"
        args: [format_hex_pretty(data).c_str()]
]]></YAML>
</Component>

<Component>
  <Name>Packet Transport</Name>
  <Category>Communication</Category>
  <Description>Enables ESPHome nodes to communicate directly by transmitting sensor and binary sensor states over supported transport channels (SX126x, SX127x, UART Bus, UDP) with optional encryption and replay protection.</Description>
  <YAML><![CDATA[
packet_transport:
  platform: udp                     # Transport platform: udp, sx126x, sx127x, uart_bus, etc.
  id: transport1                   # Optional ID for component instance
  update_interval: 15s             # Interval between broadcasts (default 15 seconds)
  encryption: "REPLACEME"          # Optional encryption key for secure transmission
  rolling_code_enable: false       # Enable rolling code to mitigate replay attacks (requires encryption)
  ping_pong_enable: false          # Enable ping-pong challenge-response for additional security
  ping_pong_recycle_time: 10min   # How often the ping-pong key is regenerated (consumer only)

  binary_sensors:                  # List of binary sensor IDs to broadcast
    - binary_sensor_1
    - binary_sensor_2

  sensors:                        # List of sensor IDs to broadcast
    - sensor_1
    - sensor_2

  providers:                      # List of provider device names with optional encryption keys
    - name: device1
      encryption: "REPLACEME"
    - name: device2

# Consumer example: receiving from provider
binary_sensor:
  - platform: packet_transport
    provider: device1
    id: binary_sensor_1
    remote_id: remote_binary_sensor_1

sensor:
  - platform: packet_transport
    provider: device1
    id: sensor_1
    remote_id: remote_sensor_1

# Connection status binary sensor (when ping-pong enabled)
binary_sensor:
  - platform: packet_transport
    provider: device1
    type: status
    name: "Device 1 connection status"
]]></YAML>
</Component>

<Component>
  <Name>ESP32 BLE Beacon</Name>
  <Category>Bluetooth</Category>
  <Description>Creates a Bluetooth Low Energy (BLE) Beacon using the ESP32 device, transmitting iBeacon packets for device tracking and location services.</Description>
  <YAML><![CDATA[
esp32_ble_beacon:
  type: iBeacon                      # Current supported beacon type
  uuid: 'c29ce823-e67a-4e71-bff2-abaa32e77a98'  # Unique identifier for the beacon

  # Optional advanced settings
  major: 10167                      # iBeacon major identifier for grouping beacons
  minor: 61958                      # iBeacon minor identifier within a group
  min_interval: 100ms               # Minimum advertising interval in milliseconds (20-10240)
  max_interval: 100ms               # Maximum advertising interval in milliseconds (20-10240)
  measured_power: -59               # RSSI at 1 meter for calibration (-128 to 0)
  tx_power: 3                      # Transmit power in dBm (-12, -9, -6, -3, 0, 3, 6, 9)

  # Optional ID for code generation
  id: ble_beacon_1
]]></YAML>
</Component>

<Component>
  <Name>BLE Client</Name>
  <Category>Bluetooth</Category>
  <Description>Manages connections to Bluetooth Low Energy devices to query and control them. Does not directly expose sensors but enables integration with other components. Supports up to 3 devices due to ESP32 BLE stack limitations.</Description>
  <YAML><![CDATA[
ble_client:
  - mac_address: XX:XX:XX:XX:XX:XX   # MAC address of BLE device to connect to (required)
    id: ble_device_1                # ID for code generation and references
    auto_connect: true              # Automatically connect when device is found (default true)

    # Automations triggered on BLE client events
    on_connect:
      then:
        - lambda: |-
            ESP_LOGD("ble_client", "Connected to BLE device");
    on_disconnect:
      then:
        - lambda: |-
            ESP_LOGD("ble_client", "Disconnected from BLE device");
    on_passkey_request:
      then:
        - ble_client.passkey_reply:
            id: ble_device_1
            passkey: 123456
    on_passkey_notification:
      then:
        - logger.log:
            format: "Enter this passkey on your BLE device: %06d"
            args: [passkey]
    on_numeric_comparison_request:
      then:
        - logger.log:
            format: "Compare this passkey with the one on your BLE device: %06d"
            args: [passkey]
        - ble_client.numeric_comparison_reply:
            id: ble_device_1
            accept: true

# Actions to control BLE connection and communication
# ble_client.connect - connect to device (if auto_connect false)
# ble_client.disconnect - disconnect device
# ble_client.ble_write - write byte array or lambda-evaluated data to BLE characteristic

# Example usage of ble_write action:
#
# switch:
#   - platform: template
#     name: "My Switch"
#     turn_on_action:
#       - ble_client.ble_write:
#           id: ble_device_1
#           service_uuid: "F61E3BE9-2826-A81B-970A-4D4DECFABBAE"
#           characteristic_uuid: "6490FAFE-0734-732C-8705-91B653A081FC"
#           value: [0x01, 0xAB, 0xFF]
]]></YAML>
</Component>

<Component>
  <Name>ESP32 BLE Tracker</Name>
  <Category>Bluetooth</Category>
  <Description>Provides a global Bluetooth Low Energy (BLE) tracker hub for ESP32 devices to scan and track BLE devices on the network, supporting advanced scan parameters and automations based on received advertisements.</Description>
  <YAML><![CDATA[
esp32_ble_tracker:
  max_connections: 3              # Maximum number of BLE connection slots (default 3, max 9 on esp-idf)
  scan_parameters:
    interval: 320ms               # Time spent scanning each BLE channel (default 320ms)
    window: 30ms                  # Time actively listening per scan interval (default 30ms)
    duration: 5min                # Total scan duration for debugging (default 5min)
    active: true                  # Whether to actively send scan requests (default true)
    continuous: true              # Whether to scan continuously or only on command (default true)
    software_coexistence: true    # Prioritize BLE over Wi-Fi on connection start (default true)

  # Automations triggered on BLE data reception events
  on_ble_advertise:
    - mac_address:
        - XX:XX:XX:XX:XX:XX      # Filter for specific MAC addresses (optional)
      then:
        - lambda: |-
            ESP_LOGD("ble_adv", "New BLE device");
            ESP_LOGD("ble_adv", " address: %s", x.address_str().c_str());
            ESP_LOGD("ble_adv", " name: %s", x.get_name().c_str());
            // Additional logging of advertised services and data

  on_ble_manufacturer_data_advertise:
    - mac_address: XX:XX:XX:XX:XX:XX
      manufacturer_id: 0590        # Manufacturer ID
      then:
        - lambda: |-
            if (x[0] != 0x7b || x[1] != 0x61) return;
            int value = x[2] + (x[3] << 8);
            id(ble_sensor).publish_state(value);

  on_ble_service_data_advertise:
    - mac_address: XX:XX:XX:XX:XX:XX
      service_uuid: 181A
      then:
        - lambda: 'id(ble_sensor).publish_state(x[0]);'

  on_scan_end:
    - then:
        - lambda: |-
            ESP_LOGD("ble_auto", "The scan has ended!");

# Actions to control scanning
# esp32_ble_tracker.start_scan - start BLE scan
# esp32_ble_tracker.stop_scan  - stop BLE scan
]]></YAML>
</Component>

<Component>
  <Name>BLE Server</Name>
  <Category>Bluetooth</Category>
  <Description>Sets up a BLE GATT server on ESP32, exposing device info and custom services with characteristics to allow data exchange and control via BLE clients.</Description>
  <YAML><![CDATA[
esp32_ble_server:
  manufacturer: "Orange"                    # Manufacturer name (default ESPHome)
  model: "ESP32 Model X"                    # Model name (default project or board name)
  appearance: 0                            # Appearance value in advertising data (default 0)
  firmware_version: "1.0.0"                # Firmware version (default ESPHome version)
  manufacturer_data: [0x4C, 0, 0x23, 77, 0xF0]  # Manufacturer-specific advertising data

  on_connect:
    - lambda: |-
        ESP_LOGD("BLE", "Connection from %d", id);

  on_disconnect:
    - lambda: |-
        ESP_LOGD("BLE", "Disconnection from %d", id);

  services:
    - uuid: "2a24b789-7aab-4535-af3e-ee76a35cc42d"    # Service UUID
      advertise: false                                # Whether to advertise this service
      characteristics:
        - uuid: "cad48e28-7fbe-41cf-bae9-d77a6c233423"  # Characteristic UUID
          id: test_characteristic
          description: "Sample description"
          read: true
          write: false
          broadcast: false
          notify: false
          indicate: false
          write_no_response: false
          value:
            data: "Hello, World!"
            type: string
            string_encoding: utf-8
          descriptors:
            - uuid: "cad48e28-7fbe-41cf-bae9-d77a6c211423"
              id: test_descriptor
              value:
                data: "Hello, World Descriptor!"
          on_write:
            then:
              - lambda: |-
                  ESP_LOGD("BLE", "Characteristic written by client");
                  
# Actions

# ble_server.characteristic.set_value - set characteristic value
# ble_server.characteristic.notify - notify clients of characteristic update
# ble_server.descriptor.set_value - set descriptor value
]]></YAML>
</Component>

<Component>
  <Name>Bluetooth Proxy</Name>
  <Category>Bluetooth</Category>
  <Description>Enables ESPHome devices to act as Bluetooth Low Energy (BLE) proxies, extending the Bluetooth coverage for Home Assistant by relaying BLE data and managing active connections with devices.</Description>
  <YAML><![CDATA[
bluetooth_proxy:
  active: true                         # Enable proxying of active BLE connections (default true)
  cache_services: true                 # Cache GATT services in flash for faster active connections (default true on ESP-IDF)
  connection_slots: 3                  # Maximum number of BLE connection slots to use (default 3, max 9 on ESP-IDF framework)

# Note:
# - ESP32 platform should use the ESP-IDF framework for better performance and memory usage
# - Disable Web Server component when enabling the Bluetooth Proxy to avoid memory issues
# - Bluetooth Proxy depends on esp32_ble_tracker component being enabled

# Recommended esp32_ble_tracker scan parameters for improved reception performance:
# esp32_ble_tracker:
#   scan_parameters:
#     interval: 1100ms
#     window: 1100ms
#     active: true

# Warning:
# Avoid placing ESP nodes near network equipment to reduce EMI interference for best Bluetooth signal reception.
]]></YAML>
</Component>

<Component>
  <Name>Improv via BLE</Name>
  <Category>Bluetooth</Category>
  <Description>Implements the open Improv standard for configuring Wi-Fi on ESP32 devices via Bluetooth Low Energy (BLE) to receive credentials securely.</Description>
  <YAML><![CDATA[
esp32_improv:
  authorizer: binary_sensor_id          # Binary sensor to authorize provisioning (required). Use 'none' to skip authorization.
  authorized_duration: 1min             # Time before authorization times out (default 1 minute)
  status_indicator: output_id           # Optional output for user feedback
  identify_duration: 10s                # Duration to identify the device (default 10 seconds)
  wifi_timeout: 1min                    # Time to wait before starting Improv service after Wi-Fi disconnect (default 1 minute)

  # Automations triggered on Improv process events
  on_start:
    then:
      - logger.log: "Improv awaiting authorization/authorized"

  on_provisioned:
    then:
      - logger.log: "Improv provisioned"

  on_provisioning:
    then:
      - logger.log: "Improv provisioning"

  on_stop:
    then:
      - logger.log: "Improv stopped"

  on_state:
    then:
      - if:
          condition:
            lambda: 'return state == improv::STATE_AUTHORIZED;'
          then:
            - logger.log: "Improv state is STATE_AUTHORIZED"

# Status Indicator Patterns:
# - solid: service active and waiting for authorization
# - blinking once/sec: awaiting Wi-Fi credentials
# - blinking 3 times/sec: identify command used
# - blinking 5 times/sec: credentials being verified and saved
# - off: service not running
]]></YAML>
</Component>

<Component>
  <Name>Nordic UART Service (NUS)</Name>
  <Category>Bluetooth</Category>
  <Description>Provides a Bluetooth Low Energy (BLE) UART interface based on the Nordic UART Service for streaming logs or enabling custom bidirectional communication.</Description>
  <YAML><![CDATA[
ble_nus:
  type: logs    # Mode of operation; set to 'logs' to stream ESPHome logs over BLE UART

# Usage:
# To view logs over BLE, run:
# esphome logs your_config.yaml --device BLE
# Or connect to a specific BLE address:
# esphome logs your_config.yaml --device 00:11:22:33:44:55
]]></YAML>
</Component>



   
</Components>  