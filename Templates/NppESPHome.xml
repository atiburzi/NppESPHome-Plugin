<Components>

<Component>
  <Name>ESP32</Name>
  <Category>Microcontrollers</Category>
  <Description>ESP32 microcontroller configuration with extended options (board variant, flash size, CPU freq, framework, advanced settings).</Description>
  <YAML><![CDATA[
esp32:                                 # https://www.esphome.io/components/esp32/   
  variant: esp32dev                    # choose the correct variant: esp32, esp32s2, esp32s3, esp32c2, esp32c3, esp32c5, esp32c6, esp32h2 or esp32p4 :contentReference[oaicite:3]{index=3}
  board: esp32dev                      # PlatformIO board ID (optional when variant is used) :contentReference[oaicite:4]{index=4}
  flash_size: 4MB                      # flash size: 2MB, 4MB, 8MB, 16MB, 32MB. Defaults often 4MB. :contentReference[oaicite:5]{index=5}
  cpu_frequency: 160MHz                # CPU frequency: 40MHz, 80MHz, 160MHz, 240MHz, 360MHz, 400MHz depending on variant :contentReference[oaicite:6]{index=6}
  framework:
    type: esp-idf                      # framework type: 'esp-idf' or 'arduino' (ESP-IDF recommended for many variants) :contentReference[oaicite:7]{index=7}
    version: recommended               # 'recommended', 'latest', or 'dev'
    source: default                    # optional custom framework source repository
    platform_version: latest           # optional override of PlatformIO package version
    sdkconfig_options:                 # optional advanced ESP-IDF configuration mapping
      CONFIG_MY_CUSTOM_OPTION: true
    log_level: INFO                    # optional log level: ERROR / NONE / WARN / INFO / DEBUG / VERBOSE
    advanced:                          # advanced settings (ESP-IDF only)
      enable_lwip_dhcp_server: false
      enable_lwip_mdns_queries: false
      enable_lwip_bridge_interface: false
      enable_lwip_tcpip_core_locking: true
      enable_lwip_check_thread_safety: true
      ignore_efuse_custom_mac: false
      ignore_efuse_mac_crc: false             # only for original ESP32 + esp-idf :contentReference[oaicite:8]{index=8}
      execute_from_psram: false               # On certain variants with PSRAM it can be enabled :contentReference[oaicite:9]{index=9}
  safe_mode: true                       # optional: enable safe mode on boot failures
  power_save_mode: none                 # optional: none / light / high
  board_build:
    flash_size: 16MB                    # example: if board has larger flash
    psram_enabled: true                 # optional: enable PSRAM if supported
    cpu_frequency: 240MHz               # example alternative CPU frequency
    build_flags:
      - "-DBOARD_HAS_PSRAM"
      - "-mfix-esp32-psram-cache-issue"
  partitions: partitions.csv            # optional: external file for partition scheme
]]></YAML>
</Component>

<Component>
  <Name>ESP8266</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller ESP8266 configuration with extended options.</Description>
  <YAML><![CDATA[
esp8266:                         # https://www.esphome.io/components/esp8266/
  board: nodemcuv2               # other options: esp01_1m, d1_mini, esp07, esp12e, esp8285, esp_wroom_02, esp210, modwifi
  framework:
    version: recommended         # options: recommended / latest / dev
  restore_from_flash: false      # restore persistent preferences from flash (true/false)
  board_flash_mode: dout         # options: qio / qout / dio / dout
  early_pin_init: true           # initialize GPIOs early (true/false)
  safe_mode: true                # enable safe mode on boot failures
  power_save_mode: none          # WiFi power saving: none / light / high
  board_build:
    flash_size: 1MB              # typical flash sizes: 512KB / 1MB / 2MB / 4MB
    cpu_frequency: 80MHz         # CPU frequency: 80MHz / 160MHz
  framework:
    type: arduino                # available type: arduino
    version: recommended         # or latest / dev
    platform_version: latest     # override PlatformIO core if needed
]]></YAML>
</Component>

<Component>
  <Name>RP2040</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller RP2040 (e.g., Raspberry Pi Pico / Pico W) configuration.</Description>
  <YAML><![CDATA[
rp2040:                          # https://www.esphome.io/components/rp2040/
  board: rpipicow                 # valid option: rpipicow (original Pico W) :contentReference[oaicite:3]{index=3}
  watchdog_timeout: 0s            # optional: reboot if hung longer than this (e.g., "500ms", "2s") :contentReference[oaicite:4]{index=4}
  framework:
    # platform_version is no longer required in newer ESPHome versions :contentReference[oaicite:5]{index=5}
    type: arduino                 # example: use Arduino-framework (if supported)
    version: latest               # optional: 'latest', 'recommended', or specific version
  board_build:
    flash_size: 2MB               # example: typical size (adjust per board)
    cpu_frequency: 133MHz         # example: typical for RP2040 (if applicable)
  safe_mode: true                 # optional: enable safe mode on boot failures
  power_save_mode: none           # optional: power saving mode: none / light / high
]]></YAML>
</Component>

<Component>
  <Name>BK72xx</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller Beken BK72xx (BK7231N/T etc) configuration via LibreTiny platform in ESPHome.</Description>
  <YAML><![CDATA[
bk72xx:                              # https://docs.libretiny.eu/docs/platform/beken-72xx/
  board: generic-bk7231n-qfn32-tuya  # example: choose correct board ID (e.g. generic-bk7231n-qfn32-tuya, generic-bk7231t-…) 
  framework:
    version: recommended             # options: recommended / latest / dev
  # Optional (advanced) parameters:
  family: bk7231n                    # optional if board auto-detects; specify if necessary
  safe_mode: true                    # optional: reboot in safe mode on boot failure
  power_save_mode: none              # optional: none / light / high
]]></YAML>
</Component>

<Component>
  <Name>RTL87xx</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller Realtek RTL87xx (e.g., RTL8710BN / RTL8710BX) configuration via LibreTiny platform.</Description>
  <YAML><![CDATA[
rtl87xx:                           # https://esphome.io/components/libretiny/
  board: generic-rtl8710bn-2mb-788k    # select the correct board ID (e.g. generic-rtl8710bx-4m-980k, generic-rtl8710bn-2mb-468k, etc.)
  framework:
    version: recommended           # options: recommended / latest / dev
    source: libretiny              # optional: specify custom LibreTiny framework source
  family: rtl8710b                 # optional: specify the chip family (rtl8710b, rtl8720c, etc.) if not auto-detected
  safe_mode: true                  # enable safe mode on boot failures
  power_save_mode: none            # WiFi power saving: none / light / high
  board_build:
    flash_size: 2MB                # adjust to your board’s flash capacity
    cpu_frequency: 125MHz          # example CPU frequency
]]></YAML>
</Component>

<Component>
  <Name>LN882x</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller LN882x (e.g., LN882HKI) configuration via LibreTiny platform for ESPHome.</Description>
  <YAML><![CDATA[
ln882x:                               # https://esphome.io/components/libretiny/
  board: generic-ln882hki             # select the correct board ID (e.g. generic-ln882hki, generic-ln882x, etc.)
  framework:
    version: recommended              # options: recommended / latest / dev
    source: libretiny                 # optional: specify a custom LibreTiny framework source
  family: ln882hki                    # optional: specify chip family if not auto-detected
  safe_mode: true                     # enable safe mode on boot failures
  power_save_mode: none               # WiFi power saving: none / light / high
  board_build:
    flash_size: 2MB                   # adjust according to the actual board
    cpu_frequency: 80MHz              # typical CPU frequency (if supported)
]]></YAML>
</Component>

<Component>
  <Name>nRF52</Name>
  <Category>Microcontrollers</Category>
  <Description>Microcontroller nRF52 (Nordic Semiconductor) configuration via ESPHome (Zephyr-based support).</Description>
  <YAML><![CDATA[
nrf52:                                     # https://www.esphome.io/components/nrf52/
  board: adafruit_feather_nrf52840         # valid example board: adafruit_itsybitsy_nrf52840, xiao_ble, … :contentReference[oaicite:3]{index=3}
  bootloader: mcuboot                      # optional: bootloader type, options include mcuboot / adafruit / adafruit_nrf52_sd132 / adafruit_nrf52_sd140_v6 / adafruit_nrf52_sd140_v7 :contentReference[oaicite:4]{index=4}
  # Optional (advanced) parameters:
  safe_mode: true                          # optional: enable safe mode on boot failure
  power_save_mode: none                    # optional: none / light / high
  dfu:
    reset_pin:
      number: P0.14                        # example pin to trigger DFU mode via USB/CDC :contentReference[oaicite:5]{index=5}
      inverted: true
]]></YAML>
</Component>

<Component>
  <Name>PSRAM</Name>
  <Category>Peripherals</Category>
  <Description>External PSRAM (Pseudo-Static RAM) configuration for ESP32 modules/boards.</Description>
  <YAML><![CDATA[
psram:                           # https://esphome.io/components/psram.html
  mode: quad                     # operating mode of PSRAM: 'quad' (default) or 'octal'
  speed: 80MHz                   # PSRAM clock speed: 40MHz (default) / 80MHz / 120MHz (120MHz only with octal mode + experimental) :contentReference[oaicite:3]{index=3}
  enable_ecc: false              # (Optional, bool) Enable ECC (Error Correction Code) for octal mode only. Default: false. :contentReference[oaicite:4]{index=4}
  disabled: false                # (Optional, bool) Don’t try to initialize PSRAM. Useful when board lacks PSRAM or PSRAM lines are used for other hardware. Default: false. :contentReference[oaicite:5]{index=5}

  # Advanced / optional settings:
  # Note: these may require specific board support or ESP-IDF/Arduino flags.
  board_build:
    flash_size: 16MB             # Example: size of external flash memory; adjust per your board (often used alongside PSRAM)
    cpu_frequency: 240MHz        # Example: CPU frequency; change according to board capabilities
  framework:
    type: esp-idf                # Example framework: esp-idf or arduino
    version: latest              # Or specific version, if needed
  platformio_options:
    build_flags:
      - "-DBOARD_HAS_PSRAM"      # Example flag to manually enable PSRAM on boards where it isn't auto-detected :contentReference[oaicite:6]{index=6}
      - "-mfix-esp32-psram-cache-issue"  # Example workaround for some ESP32-S3 boards with PSRAM cache issues :contentReference[oaicite:7]{index=7}
]]></YAML>
</Component>

<Component>
  <Name>deep_sleep</Name>
  <Category>Peripherals</Category>
  <Description>Deep sleep configuration for ESP8266/ESP32 to minimise power consumption.</Description>
  <YAML><![CDATA[
deep_sleep:                            # https://www.esphome.io/components/deep_sleep/              
  id: deep_sleep_1                     # optional identifier for referencing the component
  run_duration: 10s                    # time to run before entering sleep mode
  sleep_duration: 10min                # time to sleep before next wake-up

  # ESP32-specific wake-up options:
  wakeup_pin:
    number: GPIO33                     # RTC-capable pin on ESP32
    mode: INPUT_PULLUP                 # pin mode configuration
    inverted: false                    # wake on HIGH (false) or LOW (true)
  wakeup_pin_mode: IGNORE              # behaviour if pin is already in wake state: IGNORE / KEEP_AWAKE / INVERT_WAKEUP
  touch_wakeup: true                    # enable touchpad wake‐up (ESP32 only)
  esp32_ext1_wakeup:
    pins:
      - number: GPIO13
      - number: GPIO27
    mode: ANY_HIGH                     # mode for EXT1 wake up: ANY_LOW / ANY_HIGH / ALL_LOW

  # Conditional run durations depending on wake-up reason (ESP32 only):
  wakeup_cause_to_run_duration:
    default: 5s                         # run duration if woke by timer or unspecified cause
    gpio_wakeup_reason: 2s             # run duration if wake was caused by GPIO
    touch_wakeup_reason: 3s            # run duration if wake was caused by touchpad

  # Template/automation based entering of deep sleep:
  on_...:
    then:
      - deep_sleep.enter:
          id: deep_sleep_1
          sleep_duration: !lambda "return (lux < 10) ? 30min : 5min;"

      - deep_sleep.prevent: deep_sleep_1   # prevent sleep when certain condition holds
      - deep_sleep.allow: deep_sleep_1     # allow sleep again after prevent

  # Time-based wake up until - only ESP32:
  until: "06:00:00"                     # wake up at specified time of day
  time_id: sntp_time                   # ID of the time component to use for 'until'

  # Notes for ESP8266:
  # On ESP8266 only run_duration and sleep_duration are supported.
  # You must connect GPIO16 (D0) to the RST pin in order to wake from deep sleep.  

]]></YAML>
</Component>

<Component>
  <Name>ESP32-P4 LDO</Name>
  <Category>Peripherals</Category>
  <Description>Configuration for ESP32-P4 series boards using LDO regulator and power settings.</Description>
  <YAML><![CDATA[
esp_ldo:
  - channel: 3          # The channel number of the LDO regulator to configure. Only channels 3 and 4 are supported (1 and 2 are used internally by the chip.)
    voltage: 2.5V       # The desired output voltage - must be in the range 0.5V to 2.7V.
    adjustable: true    # If true, the output voltage can be adjusted at run-time. Defaults to false.
]]></YAML>
</Component>

<Component>
  <Name>ESPHome Core</Name>
  <Category>Core</Category>
  <Description>Main ESPHome configuration for device identity, network, logs and OTA.</Description>
  <YAML><![CDATA[
esphome:                             # https://www.esphome.io/components/esphome/
  name: my_device                    # device name (used in Home Assistant entities)
  friendly_name: "My Device"         # optional friendly name shown in UI
  platform: ESP32                    # choose correct platform: ESP8266 / ESP32 / rtl87xx / bk72xx / rp2040 / etc.
  board: esp32dev                    # optional: PlatformIO board ID if needed

# Logging configuration
logger:
  level: DEBUG                       # DEBUG / INFO / WARN / ERROR / NONE
  baud_rate: 0                       # set to 0 to disable UART logging (use USB only)

# OTA update configuration
ota:
  password: "OTA_PASSWORD"           # password for over-the-air updates
  safe_mode: true                    # enable safe mode fallback if update fails
  num_attempts: 3                    # number of OTA attempts before fallback

# Web server (optional)
web_server:
  port: 80
  include_internal: false            # include internal pages (e.g., logs, device info)
  auth:
    username: admin
    password: "WEB_PASSWORD"

# WiFi configuration (for network connectivity)
wifi:
  ssid: "Your_SSID"
  password: "Your_PASSWORD"
  fast_connect: true                 # skip waiting for network in station mode when available
  ap:
    ssid: "FallbackAP_%s"            # fallback access point if WiFi fails
    password: "AP_PASSWORD"
  manual_ip:
    static_ip: 192.168.1.50
    gateway: 192.168.1.1
    subnet: 255.255.255.0

# API configuration (integration with Home Assistant)
api:
  encryption:
    key: "32_BYTE_BASE64_KEY"        # 32 byte base64 Pre-Shared Key for encryption
  password: "API_PASSWORD"           # deprecated — use key instead
  reboot_timeout: 15min              # timeout after which auto-reboot if no communication

# Time component (optional)
time:
  - platform: homeassistant          # or sntp / rtt
    id: home_time
    timezone: "Europe/Rome"

# Device uptime and status sensor
uptime:
  id: device_uptime

# Status LED (optional)
status_led:
  pin:
    number: GPIO2
    inverted: false
]]></YAML>
</Component>

<Component>
  <Name>captive_portal</Name>
  <Category>Core</Category>
  <Description>Captive portal for connecting WiFi devices without preconfigured credentials.</Description>
  <YAML><![CDATA[
captive_portal:                     # https://esphome.io/components/captive_portal/
  id: captive_portal_main           # optional identifier
]]></YAML>
</Component>

<Component>
  <Name>external_components</Name>
  <Category>System</Category>
  <Description>Support for loading external/custom components into ESPHome.</Description>
  <YAML><![CDATA[
external_components:                        # https://www.esphome.io/components/external_components/
  - source:                                 # define source of the external component
      type: local                           # type of source: 'local' / 'git' / 'url' / 'directory'
      path: components/my_component         # path for 'local' type: relative to config folder
  dependencies:                             # optional list of other components needed
    - sensor                                # if your custom component uses sensor platform
    - switch
  reload: true                              # optional: whether changes should force full reload
]]></YAML>
</Component>

<Component>
  <Name>globals</Name>
  <Category>System</Category>
  <Description>Global variables for storing and sharing values between components and automations.</Description>
  <YAML><![CDATA[
globals:                              # https://esphome.io/components/globals/
  - id: counter_value                 # unique variable identifier
    type: int                         # variable type: int / float / bool / std::string / custom
    restore_value: yes                # restore last value from flash on boot (yes/no)
    initial_value: '0'                # initial value (stringified)
  - id: is_enabled
    type: bool
    restore_value: no
    initial_value: 'true'
  - id: temperature_offset
    type: float
    restore_value: yes
    initial_value: '1.5'
]]></YAML>
</Component>

<Component>
  <Name>interval</Name>
  <Category>Automation</Category>
  <Description>Defines recurring timed actions executed at fixed intervals.</Description>
  <YAML><![CDATA[
interval:                            # https://esphome.io/components/interval.html
  - interval: 10s                    # time between executions (supports s, min, h, ms)
    then:                            # actions to perform every interval
      - logger.log: "10-second interval triggered"
      - lambda: |-
          id(counter_value) += 1;    // example using a global variable
      - switch.turn_on: led_power
      - delay: 1s
      - switch.turn_off: led_power

  - interval: 1min
    then:
      - logger.log:
          level: INFO
          format: "Running periodic task every minute"
      - component.update: my_sensor  # manually triggers sensor reading
]]></YAML>
</Component>

<Component>
  <Name>wifi</Name>
  <Category>Network</Category>
  <Description>WiFi configuration for ESPHome devices, including credentials, static networking, power settings and fallback AP.</Description>
  <YAML><![CDATA[
wifi:                                 # https://www.esphome.io/components/wifi/
  ssid: "MyWiFiNetwork"               # The name (SSID) of the WiFi network to connect to
  password: "MyWiFiPassword"          # The password for your WiFi network; leave blank for open networks
  # For connecting to multiple networks, use the networks: list instead of ssid/password
  # networks:
  #   - ssid: "FirstNetwork"
  #     password: "Password1"
  #   - ssid: "SecondNetwork"
  #     password: "Password2"

  manual_ip:                          # (optional) Set a static IP address instead of using DHCP
    static_ip: 192.168.1.100          # The static IP address to assign to this device
    gateway: 192.168.1.1              # Your router's IP address
    subnet: 255.255.255.0             # Subnet mask, usually 255.255.255.0
    dns1: 8.8.8.8                     # (optional) Primary DNS server
    dns2: 1.1.1.1                     # (optional) Secondary DNS server

  ap:                                 # (optional) Enable fallback Access Point mode
    ssid: "FallbackHotspot"           # SSID for the fallback AP if WiFi connection fails
    password: "FallbackPassword"      # Password for the hotspot; leave empty for an open AP

  power_save_mode: none               # (optional) WiFi power saving mode: none, light, or high
  output_power: 20dB                  # (optional) WiFi transmit power. Default for ESP32/ESP8266 is 20dB
  fast_connect: false                 # (optional) Skip full WiFi scan for faster connection. Use for hidden or single APs
  reboot_timeout: 15min               # (optional) Time to reboot after losing WiFi, default 15min

  on_connect:                         # (optional) Actions when the device connects to WiFi
    then:
      - logger.log: "Connected to WiFi!"

  on_disconnect:                      # (optional) Actions when the device disconnects from WiFi
    then:
      - logger.log: "Disconnected from WiFi!"

  enable_on_boot: true                # (optional) Whether WiFi is enabled at boot. Default is true

  domain: ".local"                    # (optional) mDNS domain to use, default is ".local"
  use_address: 192.168.1.100          # (optional) Override the address used to connect from Home Assistant
 ]]></YAML>
</Component>

<Component>
  <Name>ethernet</Name>
  <Category>Network</Category>
  <Description>Configuration of Ethernet connectivity for ESPHome, including PHY type, pins and network settings.</Description>
  <YAML><![CDATA[
ethernet:                              # https://www.esphome.io/components/ethernet/
  type: LAN8720                        # The Ethernet chip type; options: LAN8720, IP101, RTL8201, W5500, DM9051, OPENETH, LAN8670
  mdc_pin: GPIO23                      # (Required for RMII chips) Pin for MDC signal
  mdio_pin: GPIO18                     # (Required for RMII chips) Pin for MDIO signal
  clk:                                 # (Required for RMII chips) Clock configuration object
    pin: GPIO17                        # Pin connected to Ethernet clock module
    mode: CLK_OUT                      # Clock mode: CLK_OUT (internal) or CLK_EXT_IN (external)
  phy_addr: 0                          # (Optional) Address of the Ethernet PHY chip; default is 0
  power_pin: GPIO12                    # (Optional) Pin that controls Ethernet power/reset

  manual_ip:                           # (Optional) Set a static IP instead of DHCP
    static_ip: 192.168.1.42            # IP address for this device
    gateway: 192.168.1.1               # Gateway (usually your router)
    subnet: 255.255.255.0              # Subnet mask, normally 255.255.255.0
    dns1: 8.8.8.8                      # (Optional) Primary DNS server
    dns2: 1.1.1.1                      # (Optional) Secondary DNS server

  mac_address: "AA:BB:CC:DD:EE:FF"     # (Optional) Custom MAC address for the interface
  domain: ".local"                     # (Optional) mDNS or upload domain, default: ".local"
  use_address: 192.168.1.42            # (Optional) Override IP for OTA uploads or Home Assistant

  id: my_eth_interface                 # (Optional) Internal reference ID

  phy_registers:                       # (Optional) Custom register overrides for the PHY (advanced)
    - address: 0x10                    # Register address in hexadecimal
      value: 0x1FFA                    # Value for this register
      page_id: 0x07                    # (Optional) Page to select before writing (RTL8201 only)
]]></YAML>
</Component>

<Component>
  <Name>esp32_hosted</Name>
  <Category>Hardware</Category>
  <Description>ESP-Hosted co-processor configuration: use an ESP32 module as a network (Wi-Fi / BT) co-processor for a host MCU.</Description>
  <YAML><![CDATA[
esp32_hosted:                         # https://www.esphome.io/components/esp32_hosted/
  variant: ESP32C6                    # ESP32 co-processor variant (e.g. ESP32, ESP32S2, ESP32S3, ESP32C2, ESP32C3, ESP32C6)
  reset_pin: GPIOXX                   # Pin used to reset the co-processor
  cmd_pin: GPIOXX                     # Pin for command/data signaling (see board reference)
  clk_pin: GPIOXX                     # Pin for clock signal if required (refer to hardware)
  d0_pin: GPIOXX                      # Data line 0 (use hardware guidelines for pinout)
  d1_pin: GPIOXX                      # Data line 1
  d2_pin: GPIOXX                      # Data line 2
  d3_pin: GPIOXX                      # Data line 3
  active_high: true                   # If true, co-processor is active when reset pin is high (otherwise, when low)
  phy_addr: 1                         # (Optional) PHY address, if multiple chips may need configuration
  id: my_esp32_hosted                 # (Optional) Internal reference name for this hosted interface

  wifi:                               # Wireless configuration for the hosted ESP32 co-processor
    ssid: !secret wifi_ssid           # WiFi SSID for the network
    password: !secret wifi_password   # WiFi Password for the network

# Additional advanced options (if needed)

  manual_ip:                          # (Optional) Static IP configuration for the wireless interface
    static_ip: 192.168.1.42           # Device IP address to assign
    gateway: 192.168.1.1              # Gateway router address
    subnet: 255.255.255.0             # Network subnet mask
    dns1: 8.8.8.8                     # (Optional) Primary DNS server
    dns2: 1.1.1.1                     # (Optional) Secondary DNS server

  mac_address: "AA:BB:CC:DD:EE:FF"    # (Optional) Custom MAC address for ESP32 Hosted chip

  domain: ".local"                    # (Optional) mDNS domain for network discovery, default ".local"
  use_address: 192.168.1.42           # (Optional) Override the address used for integration or OTA

  on_connect:                         # (Optional) Automations for successful connection
    then:
      - logger.log: "ESP32 Hosted is connected!"

  on_disconnect:                      # (Optional) Automations for lost connection
    then:
      - logger.log: "ESP32 Hosted was disconnected!"
]]></YAML>
</Component>

<Component>
  <Name>openthread</Name>
  <Category>Network</Category>
  <Description>Configuration for Thread networking using OpenThread on ESPHome devices (e.g. ESP32-C6, ESP32-H2).</Description>
  <YAML><![CDATA[
openthread:                           # https://esphome.io/components/openthread.html
  device_type: FTD                     # Thread device type: FTD (Full Thread Device) or MTD (Minimal Thread Device)
  channel: 13                          # Thread channel (11-26)
  network_name: "OpenThread-Network"   # Human-readable network name
  network_key: 0x0123456789abcdef0123456789abcdef  # 16-byte network key
  pan_id: 0x1234                       # 2-byte PAN ID
  ext_pan_id: 0x1122334455667788       # 8-byte Extended PAN ID
  pskc: 0xaabbccddeeff001122334455667788  # PSKc for commissioner authentication (optional)
  mesh_local_prefix: "fd00:1234:5678:9abc::/64"  # IPv6 mesh-local prefix
  
  force_dataset: true                  # Force your dataset rather than using defaults  
                                        # (useful when migrating or controlling dataset manually)

  # Alternatively, you can provide full TLV dataset from Home Assistant (e.g., via Thread Commissioning):
  # tlv: "0e08000000000001000000030000..."  # Full Thread Dataset TLV as hex string

  # Optional: callback for factory reset (if you want to reset Thread config on device)
  on_factory_reset:
    then:
      - lambda: |-
          ESP_LOGW("openthread", "Factory reset triggered");  
          id(openthread_component).defer_factory_reset_external_callback();

  id: openthread_component              # Optional identifier to reference this component
]]></YAML>
</Component>

<Component>
  <Name>api</Name>
  <Category>Communication</Category>
  <Description>Native API for direct communication between ESPHome devices and Home Assistant, including encryption, services, and callbacks.</Description>
  <YAML><![CDATA[
api:                                  # https://esphome.io/components/api.html
  id: api_component                    # Optional identifier
  port: 6053                           # Default port for ESPHome Native API
  password: !secret api_password       # (Optional) password for protecting API access
  encryption:
    key: !secret api_encryption_key    # 16-byte key (Base64 encoded) for secure communication
  reboot_timeout: 0s                   # Disable auto-reboot if API disconnected (0s = disabled)
  debug: false                         # Enable low-level API message logging
  services:
    - service: set_led_brightness
      variables:
        brightness: int
      then:
        - logger.log: "Setting LED brightness from API"
        - lambda: |-
            id(my_led).set_level(brightness / 100.0f);

    - service: reboot_device
      then:
        - logger.log: "Reboot requested via API"
        - button.press: restart_button

  on_client_connected:
    - logger.log: "Home Assistant connected to device"
  on_client_disconnected:
    - logger.log: "Home Assistant disconnected"
]]></YAML>
</Component>

<Component>
  <Name>mqtt</Name>
  <Category>Communication</Category>
  <Description>MQTT client configuration for ESPHome devices, enabling communication via an external MQTT broker.</Description>
  <YAML><![CDATA[
mqtt:                                 # https://esphome.io/components/mqtt.html
  broker: 192.168.1.10                # MQTT broker address (IP or hostname)
  port: 1883                          # Default MQTT port
  username: !secret mqtt_user         # Optional username
  password: !secret mqtt_pass         # Optional password
  client_id: esphome_device           # MQTT client identifier
  topic_prefix: my_device             # Prefix for all MQTT topics
  discovery: true                     # Enable MQTT discovery for Home Assistant
  birth_message:
    topic: esphome/lifecycle
    payload: "online"                 # Message when the device boots
    qos: 1
  will_message:
    topic: esphome/lifecycle
    payload: "offline"                # Message when the device disconnects unexpectedly
    qos: 1
    retain: false
  log_topic: esphome/logs             # Publish device logs to MQTT
  keepalive: 15s                      # Keepalive interval
  reboot_timeout: 0s                  # Disable auto-reboot on MQTT disconnect
  on_message:
    - topic: esphome/command/restart  # Custom MQTT command
      then:
        - button.press: restart_button
  id: mqtt_component                  # Internal identifier
]]></YAML>
</Component>

<Component>
  <Name>esp_now</Name>
  <Category>Communication</Category>
  <Description>ESP-NOW peer-to-peer wireless communication for ESPHome devices, enabling low-latency and connectionless messaging.</Description>
  <YAML><![CDATA[
esp_now:                              # https://esphome.io/components/esp_now.html
  wifi_channel: 6                     # WiFi/ESP-NOW must operate on the same channel
  enable_wake_from_sleep: false       # Allow ESP-NOW to wake device from light sleep (ESP32 only)
  id: espnow_component                # Optional identifier
  encryption:
    key: "00112233445566778899AABBCCDDEEFF"   # 16-byte hex key for secure peer communication
  peers:
    - mac_address: "A4:CF:12:00:11:22"  # MAC of another ESP-NOW device
      channel: 6                        # Must match both devices
      encryption_key: "00112233445566778899AABBCCDDEEFF"
      id: peer_device_1                 # Optional internal reference

    - mac_address: "24:6F:28:AA:BB:CC"
      channel: 6
      id: peer_device_2
  on_receive:
    then:
      - lambda: |-
          ESP_LOGI("esp-now", "Received %d bytes from %s",
            data.size(), mac_address.c_str());
  on_boot:
    priority: -100
    then:
      - esp_now.send:
          peer_id: peer_device_1
          data: "Hello World"
]]></YAML>
</Component>

<Component>
  <Name>http_request</Name>
  <Category>Communication</Category>
  <Description>HTTP client to perform GET, POST, PUT, PATCH or DELETE requests from ESPHome devices.</Description>
  <YAML><![CDATA[
http_request:                         # https://esphome.io/components/http_request.html
  id: http_client                      # Optional identifier
  verify_ssl: false                    # Disable certificate validation (for self-signed HTTPS)
  timeout: 10s                         # Global HTTP request timeout
  useragent: "ESPHome/1.0"
  headers:
    Authorization: "Bearer ABCDEF123456"
    X-Custom-Header: "CustomValue"
on_boot:
  priority: -10
  then:
    - http_request.get:
        url: http://example.com/api/status
        headers:
          Accept: "application/json"
script:
  - id: send_data
    mode: queued
    then:
      - http_request.post:
          url: http://example.com/api/data
          headers:
            Content-Type: "application/json"
          json:
            temperature: !lambda 'return id(temp_sens).state;'
            humidity: !lambda 'return id(hum_sens).state;'
  - id: send_custom_raw
    then:
      - http_request.post:
          url: http://example.com/submit
          body: "raw text message"
  - id: call_webhook
    then:
      - http_request.post:
          url: https://hooks.nabu.casa/.../trigger_event
          json:
            device: "sensor-node"
            status: "online"

]]></YAML>
</Component>
   
</Components>  